/* BSD License
 *
 * Copyright (c) 2006, Harald Wellmann, Harman/Becker Automotive Systems
 * All rights reserved.
 * 
 * This software is derived from previous work
 * Copyright (c) 2003, Godmar Back.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the name of Harman/Becker Automotive Systems or
 *       Godmar Back nor the names of their contributors may be used to
 *       endorse or promote products derived from this software without
 *       specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package datascript;

import java.io.File;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import datascript.parser.DSConstants;
import datascript.syntaxtree.Node;

public class JavaBytesEmitter
{
    final static String RUNTIME_PKG = "datascript.runtime.";
    final static String FQ_OUTPUT_STREAM = "datascript.runtime.BitArrayStreamWriter";
    final static String OUTPUT_STREAM = "BitArrayStreamWriter";
    final static String FQ_INPUT_STREAM = "datascript.runtime.BitArrayStreamReader";
    final static String INPUT_STREAM = "BitArrayStreamReader";
    final static String FQ_IO_EXCEPTION = "java.io.IOException";
    final static String IO_EXCEPTION = "IOException";
    final static String CALL_CHAIN_TYPE = RUNTIME_PKG + "CallChain";

    final String CHOICETAG = "__choice";
    final String DEPTHFIRST = "__DepthFirstVisitor";
    final String VISITOR = "__Visitor";
    final String CHECKTHAT = "__CheckThat";
    final String ACCEPTOR = "Acceptor";
    final String FQ_ACCEPTOR = VISITOR + "." + ACCEPTOR;
    final String SIZEOF = "__SizeOf";

    PrintWriter out = null;
    private String pkgname; // by default taken from [basename].ds
    String dirname; // pkgname converted to dirname (. replaced with /)
    private HashMap fieldName2armName;
    private HashMap armName2armType;

    private HashMap ctype2armNameMapping = new HashMap();
    private HashMap ctype2armTypeMapping = new HashMap();

    JavaBytesEmitter(String dirname, String pkgname)
    {
        this.pkgname = pkgname;
        this.dirname = dirname;
    }

    void writeHeader()
    {
        writeHeader(out);
    }

    void writeHeader(PrintWriter out)
    {
        out.println("// Generated by Siemens VDO automotive Version 0.1(Merging)");
        out.println();
        out.println("package " + pkgname + ";");
        out.println();
        out.println("import java.io.OutputStream;");
        out.println("import " + RUNTIME_PKG + "*;");
        out.println("import java.util.*;");
        out.println("import java.io.File;");
        out.println("import java.math.BigInteger;");
        out.println("import java.io.OutputStream;");
        out.println("import " + FQ_IO_EXCEPTION + ";");
        out.println("import " + FQ_OUTPUT_STREAM + ";");
        out.println("import " + FQ_INPUT_STREAM + ";");
        out.println();
    }

    void emit(CompoundType type)
    {
        if (Main.emitvisitors)
        {
            emitSizeOfVisitor();
            emitContainedTypes(type, "", /* isTop= */true);
        }
    }

    void emitContainedTypes(CompoundType type, String indent)
    {
        emitContainedTypes(type, indent, false);
    }

    void emitContainedTypes(CompoundType type, String indent, boolean isTop)
    {
        for (Iterator i = type.getNestedTypes(); i.hasNext();)
        {
            emit((CompoundType) i.next(), indent, isTop);
        }
    }

    void emit(CompoundType type, String indent, boolean isTop)
    {
        if (type.isEmpty())
        {
            return;
        }

        if (isTop)
        {
            if (out != null)
            {
                out.close();
            }
            out = Main.openFile(dirname + File.separator + type.getName()
                    + ".java");
            if (out == null)
                return;
            writeHeader();
        }

        out.print(indent);
        out.print("public class " + type.getName());// + " implements
                                                    // datascript.runtime.Writer");
        if (Main.emitvisitors)
        {
            out.print(" implements " + FQ_ACCEPTOR
                    + ", datascript.runtime.SizeOf");
        }
        out.println(" {");

        type.computeBitFieldOffsets(0);
        emitContainedTypes(type, indent + "  ");
        emitConditions(type, indent + "  ");
        emitParameterMembers(type, indent + "  ");
        out.println(indent + "  long __fpos;  // stream pos at start of input");
        if ( !(type instanceof UnionType) )
        {
            out.println(indent + "  /* this class is a struct */");
            emitStructFieldDefinitions(type, indent);
            emitStructConstructor(type, indent);
            emitStructWrite(type, indent);
        }
        else
        {
            out.println(indent + "  /* this class is a union */");
            emitUnionFieldDefinitions(type, indent);
            emitUnionConstructors(type, indent);
            emitUnionAccessors(type, indent);
            emitUnionWrite(type, indent);
        }
        emitSourceConstructor(type, indent);
        emitSourceReader(type,indent);
         emitWriteNewCallChain(type, indent);
        if (Main.emitvisitors)
        {
            emitAccept(indent, VISITOR);
            out.println();
            emitSizeOf(type, indent, VISITOR);
        }
        // emit foralls at the end
        out.println(JavaExpressionEmitter.emitForalls(type, indent));
        out.println(indent + "}");
        out.println();
        out.flush();
    }

    void emitSizeOfVisitor()
    {
        out = Main.openFile(dirname + File.separator + SIZEOF + ".java");
        if (out == null)
            return;

        writeHeader();
        int[] t = { DSConstants.INT8, DSConstants.INT16, DSConstants.INT32,
                DSConstants.INT64, DSConstants.LEINT16, DSConstants.LEINT32,
                DSConstants.LEINT64, DSConstants.UINT8, DSConstants.UINT16,
                DSConstants.UINT32, DSConstants.UINT64, DSConstants.LEUINT16,
                DSConstants.LEUINT32, DSConstants.LEUINT64 };

        String cname = SIZEOF;
        out.println("public class " + cname + " extends " + DEPTHFIRST + " {");
        out.println("  private int sz = 0;");
        for (int i = 0; i < t.length; i++)
        {
            TypeInterface type = BuiltinType.getTypeByTokenKind(t[i]);
            out.println("  public void visit" + type + "("
                    + JavaBytesEmitter.printType(type) + " n) {");
            out.println("    sz += 8 * " + type.sizeof(null) + ";");
            out.println("  }");
        }

        String[] bftypes = new String[] { "byte", "short", "int", "long",
                "BigInteger" };

        for (int i = 0; i < bftypes.length; i++)
        {
            out.println("  public void visitBitField(" + bftypes[i]
                    + " n, int length) {");
            out.println("    sz += length;");
            out.println("  }");
        }
        out.println();

        out.println("  public static int sizeof(" + FQ_ACCEPTOR + " a) {");
        out.println("    " + cname + " v = new " + cname + "();");
        out.println("    a.accept(v);");
        out.println("    if (v.sz % 8 != 0) {");
        out.println("      throw new RuntimeException("
                + "\"sizeof not integer: \" + v.sz);");
        out.println("    }");
        out.println("    return v.sz / 8;");
        out.println("  }");
        out.println("}");
        out.close();
    }

    private void emitSizeOf(CompoundType type, String indent, String visitorname)
    {
        indent += "  ";
        out.print(indent + "public int sizeof() {");

        try
        {
            // see if we know sizeof at compile time
            out.println(" return "
                    + type.sizeof(type.getScope()).integerValue() + "; }");
        }
        catch (ComputeError e)
        {
            // no, must compute at run time
            out.println();
            out.println(indent + "  return " + SIZEOF + ".sizeof(this);");
            out.println(indent + "}");
        }
    }

    private void emitAccept(String indent, String visType)
    {
        indent += "  ";
        out.println(indent + "public void accept(" + visType + " visitor) {");
        out.println(indent + "  visitor.visit(this);");
        out.println(indent + "}");
    }

    private void emitConditions(CompoundType type, String indent)
    {
        Iterator i = type.getConditions();
        while (i.hasNext())
        {
            Condition c = (Condition) i.next();
            Scope s = c.getScope();
            out.print(indent + "boolean " + c.getName() + "(");
            for (int j = 0; j < c.getNumberOfParameters(); j++)
            {
                String pname = c.getParameter(j).getName();
                TypeInterface ptype = c.getParameter(j).getType();
                out.print(printType(ptype) + " " + pname);
                if (j < c.getNumberOfParameters() - 1)
                    out.print(", ");
            }
            out.println(") {");
            out.println(indent + "  try {");
            out.println(indent + "    if (false) throw new " + IO_EXCEPTION
                    + "(); /* placate compiler */");
            out.println(indent + "    return (");
            out.print(indent + "(");
            for (Iterator ei = c.getExpressions(); ei.hasNext();)
            {
                ExpressionTypeCheckVisitor jvis;
                JavaExpressionEmitter em;
                Node expr = (Node) ei.next();

                em = new JavaExpressionEmitter(type, c.getScope());
                jvis = new ExpressionTypeCheckVisitor(type, c.getScope(), em);
                expr.accept(jvis);
                out.println(em.result() + ")");
                if (ei.hasNext())
                    out.print(indent + "         && (");
            }
            out.println(indent + "         );");
            out.println(indent
                    + "  } catch (ArrayIndexOutOfBoundsException _) {");
            out.println(indent + "    return false;");
            out.println(indent + "  } catch (" + IO_EXCEPTION + " __) {");
            out.println(indent + "    return false;");
            out.println(indent + "  }");
            out.println(indent + "}\n");
        }
    }

    /**
     * add a compound's parameters (if it has any) to a parameter list in a
     * constructor or elsewhere. We assume that the other parameters have
     * already been emitted.
     */
    private String additionalParameterList(CompoundType ctype, boolean withTypes)
    {
        if (!ctype.hasParameters())
        {
            return "";
        }
        Iterator i = (Iterator) ctype.getParameters();
        StringBuffer b = new StringBuffer();
        while (i.hasNext())
        {
            Parameter p = (Parameter) i.next();
            b.append(", ");
            if (withTypes)
            {
                b.append(printType(p.getType()) + " ");
            }
            b.append(p.getName());
        }
        return b.toString();
    }

    private void emitParameterMembers(CompoundType ctype, String indent)
    {
        if (!ctype.hasParameters())
        {
            return;
        }
        out
                .println(indent
                        + "/* additional parameters this type depends on */");
        Iterator i = (Iterator) ctype.getParameters();
        while (i.hasNext())
        {
            Parameter p = (Parameter) i.next();
            out.println(indent + printType(p.getType()) + " " + p.getName()
                    + ";");
        }
    }

    private void setAdditionalParameters(CompoundType ctype, String indent)
    {
        if (!ctype.hasParameters())
        {
            return;
        }
        Iterator i = (Iterator) ctype.getParameters();
        while (i.hasNext())
        {
            Parameter p = (Parameter) i.next();
            out.println(indent + "  this." + p.getName() + " = " + p.getName()
                    + ";");
        }
    }

    private void emitSourceReader(CompoundType type, String indent)
    {
    	String aplist = additionalParameterList(type, false);
    	String aplistwtypes = additionalParameterList(type, true);
    	
    	if(aplistwtypes != ""){
    		out.println(indent + "  public " + "void read" 
    				+ "(byte[] b_array) throws "
    				+ IO_EXCEPTION + " {");
    		out.println(indent + "    read(new " + INPUT_STREAM
    				+ "(b_array), new " + CALL_CHAIN_TYPE + "()" + aplist
    				+ ");");
    		out.println(indent + "  }");
    		out.println();
    		out.println();
    	}
    	
    	
    	out.println(indent + "  public " + "void read" 
    			+ "(byte[] b_array" + aplistwtypes + ") throws "
    			+ IO_EXCEPTION + " {");
    	out.println(indent + "    read(new " + INPUT_STREAM
    			+ "(b_array), new " + CALL_CHAIN_TYPE + "()" + aplist
    			+ ");");
    	out.println(indent + "  }");
    	out.println();
    	out.println();
    	
    	out.println(indent + "  public " + "void read" + "(" + INPUT_STREAM
    			+ " __in" + aplistwtypes + ") throws " + IO_EXCEPTION + " {");
    	out.println(indent + "    read(__in, new " + CALL_CHAIN_TYPE + "()"
    			+ aplist + ");");
        out.println(indent + "  }");
        out.println();

        out.println(indent + "  public " + "void read" + "(" + INPUT_STREAM
                + " __in, " + CALL_CHAIN_TYPE + " __cc" + aplistwtypes
                + ") throws " + IO_EXCEPTION + " {");
        out.println(indent + "    try {");

        out.println(indent + "      __cc.push(" + "\"" + printType(type)
                + "\", this);");
        setAdditionalParameters(type, indent + "    ");
        /*
         * handle special case of partial bitfield in subtype we roll input
         * stream back to beginning of bitfield chain
         */
        if (false /* HWE */&& type.getField(0).isBitField()
                && type.getField(0).bitFieldOffset != 0)
        {
            int boffset = (type.getField(0).bitFieldOffset + 7) / 8;
            out.println(indent + "      __in.seek(__in.getStreamPosition() - "
                    + boffset + ");");
        }

        if (type instanceof UnionType)
        {
            emitUnionInputConstructor(type, indent + "  ");
        }
        else
        {
        	
            emitStructInputConstructor(type, indent + "  ");
        }
        out.println(indent + "    } finally { __cc.pop(); }");
        out.println(indent + "  }");
        out.println();
    }
    
    private void emitSourceConstructor(CompoundType type, String indent)
    {
        String aplist = additionalParameterList(type, false);
        String aplistwtypes = additionalParameterList(type, true);
        if (Main.stringconstructor)
        {
            out.println(indent + "  public " + type.getName()
                    + "(byte[] b_array" + aplistwtypes + ") throws "
                    + IO_EXCEPTION + " {");
            out.println(indent + "    this(new " + INPUT_STREAM
                    + "(b_array), new " + CALL_CHAIN_TYPE + "()" + aplist
                    + ");");
            out.println(indent + "  }");
            out.println();
        }

        out.println(indent + "  public " + type.getName() + "(" + INPUT_STREAM
                + " __in" + aplistwtypes + ") throws " + IO_EXCEPTION + " {");
        out.println(indent + "    this(__in, new " + CALL_CHAIN_TYPE + "()"
                + aplist + ");");
        out.println(indent + "  }");
        out.println();

        out.println(indent + "  public " + type.getName() + "(" + INPUT_STREAM
                + " __in, " + CALL_CHAIN_TYPE + " __cc" + aplistwtypes
                + ") throws " + IO_EXCEPTION + " {");
        out.println(indent + "    try {");

        out.println(indent + "      __cc.push(" + "\"" + printType(type)
                + "\", this);");
        setAdditionalParameters(type, indent + "    ");
        /*
         * handle special case of partial bitfield in subtype we roll input
         * stream back to beginning of bitfield chain
         */
        if (false /* HWE */&& type.getField(0).isBitField()
                && type.getField(0).bitFieldOffset != 0)
        {
            int boffset = (type.getField(0).bitFieldOffset + 7) / 8;
            out.println(indent + "      __in.seek(__in.getStreamPosition() - "
                    + boffset + ");");
        }

        if (type instanceof UnionType)
        {
            emitUnionInputConstructor(type, indent + "  ");
        }
        else
        {
        	
            emitStructInputConstructor(type, indent + "  ");
        }
        out.println(indent + "    } finally { __cc.pop(); }");
        out.println(indent + "  }");
        out.println();
    }

    void emitWriteNewCallChain(CompoundType type, String indent)
    {
        out.println(indent + "  public void write(java.io.DataOutput" +
        		" __out) throws " + IO_EXCEPTION + " {");
        out
                .println(indent + "    write(new BitArrayStreamWriter((OutputStream)__out), new " + CALL_CHAIN_TYPE
                        + "());");
        out.println(indent + "  }");
        out.println();
//        out.println(indent + "  public void write(String __filename) "
//                + "throws " + IO_EXCEPTION + " {");
//        out.println(indent + "    write(new FileImageOutputStream("
//                + "new File(__filename)));");
//        out.println(indent + "  }");
        out.println();
    }

    void emitUnionWrite(CompoundType type, String indent)
    {
        out.println(indent + "  public void write(BitArrayStreamWriter" // +
                                                                        // OUTPUT_STREAM
                + " __out, " + CALL_CHAIN_TYPE + " __cc) throws "
                + IO_EXCEPTION + " {");
        out.println(indent + "    __cc.push(" + "\"" + printType(type)
                + "\", this);");
        out.println(indent + "    switch (" + CHOICETAG + ") {");

            
        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            TypeInterface ftype = f.getType();
            out.println(indent + "    case CHOICE_" + f.getName() + ":");
            String a = (String) fieldName2armName.get(f.getName());
            emitCheckFieldCondition(indent + "         ", f, a, type);

           

            if (ftype instanceof CompoundType )
            {
            	 CompoundType ctype = (CompoundType) ftype;
                 if (!((CompoundType)type).isEmpty())
                 {
                     out.println(indent + "         ((" + ftype.toString() + ")"
                             + a + ").write(__out, __cc);");
                 }
                
            }else if( ftype instanceof TypeInstantiation)
            {
            	out.println(indent + "         ((" + ftype.toString() + ")"
                        + a + ").write(__out, __cc);");
            }
            else if (ftype instanceof StringType)
            {
                out.println(indent + "  __out.writeUTF(" + a + ");");
            }
            else if ( ftype instanceof ArrayType){
            	out.println(indent + "  " + a + ".write(__out, __cc);");
            }
            else
            {
            	BuiltinType btype = BuiltinType.getBuiltinType(ftype);
            	 Context ctxt = type.getScope();
            	
            	  if (f.isBitField())
                  {
            		  BitFieldType bftype = (BitFieldType) btype;
            		  out.print(indent);
            		  writeBitFieldType(bftype, f.getCompound(), ctxt, a);
            		  out.println(";");
                  }else{
                	  
                	  
                	  out.print(indent + "  __out.");
                	  writeBuiltinType(btype.kind,a);
                  }
            }
            out.println(indent + "         break;");
        }

        out.println(indent + "    }");
        out.println(indent + "__out.flush_all();");
        out.println(indent + "    __cc.pop();");
        out.println(indent + "  }");
        out.println();
    }

    private void tryNextField(Iterator i, String indent, int excNum,
            CompoundType ctype)
    {
        Field f = (Field) i.next();
        indent += "  ";

        readField(f, ctype, excNum, indent);
        if (i.hasNext())
        {
            tryNextField(i, indent, excNum + 1, ctype);
        }
        else
        {
            out.println(indent + "    throw __exc_" + excNum + ";");
        }
        out.println(indent + "  }");
    }

    private void readField(Field f, CompoundType ctype, int excNum,
            String indent)
    {
        out.println(indent + "  try {");
        if (Main.debugoutput)
        {
            Field.LookAhead l = f.getLookAhead();
            if (l != null)
                out.println("// lookahead: " + l);
            else
                out.println("// no lookahead found");

            out.println(indent + "    System.out.println(\"" + indent
                    + f.getCompound() + "." + f.getName()
                    + " (union arm) might start here; fpos = \" + __fpos);");
        }
        emitLabelExpression(f, ctype, indent);

        String fname = null;
        TypeInterface ftype = f.getType();
        if (ftype instanceof CompoundType || ftype instanceof TypeInstantiation)
        {
            emitObjectInput(indent, fname = "object_choice", ftype, ctype);
        }
        else if (ftype instanceof ArrayType)
        {
            emitArrayInput(indent, f, fname = "array_choice", ctype);
        }
        else
        {
            emitBuiltinTypeInput(indent, f, fname = (String) fieldName2armName
                    .get(f.getName()), ctype.getScope());
        }
        out.println(indent + "    this." + CHOICETAG + " = CHOICE_"
                + f.getName() + ";");
        emitCheckFieldCondition(indent + "    ", f, fname, ctype);

        // please the compiler
        if (ftype instanceof CompoundType && ((CompoundType) ftype).isEmpty())
        {
            out.println(indent + "    if (false) throw new " + IO_EXCEPTION
                    + "();");
        }
        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + f.getName() + " seen!\");");
        }
        out.println(indent + "  } catch (" + IO_EXCEPTION + " __exc_" + excNum
                + ") {");
        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + f.getName() + " failed: \" + __exc_" + excNum + ");");
        }
        out.println(indent + "    __in.setBitPosition(__fpos);");
    }

    void emitUnionInputConstructor(CompoundType type, String indent)
    {
        out.println(indent + "    __fpos = __in.getBitPosition();");
        int excNum = 0;
        Field.LookAhead tla = type.getLookAhead();
        if (tla == null)
        {
            out
                    .println(indent
                            + "    // Sorry, I was unable to determine a lookahead for this union type");
            tryNextField(type.getFields(), indent, excNum, type);
            out.println();
        }
        else
        {
            if (Main.debugoutput)
                out.println(indent + "    // type has lookahead " + tla);
            if (tla.getOffset() == 0)
            {
                String la = "__lookahead";

                // We now have a valid lookahead set, so let's output a switch
                // statement.
                // little/big endian should be covered by lookahead.getKind()
                // int type is the only type java allows us to switch() on.
                // But it won't work >=32bit unsigned when comparing
                String latype = "int";
                String lacmptype = "int";

                String signexp = null, signexp2 = null;
                // suppress sign extension
                switch (tla.getKind())
                {
                    case DSConstants.UINT8:
                        signexp = "0xff";
                        break;
                    case DSConstants.UINT16:
                    case DSConstants.LEUINT16:
                        signexp = "0xffff";
                        break;
                    case DSConstants.UINT32:
                    case DSConstants.LEUINT32:
                        signexp2 = "0xffffffffL";
                        lacmptype = "long";
                        break;
                    case DSConstants.INT64: // these two could work, I guess
                    case DSConstants.LEINT64:
                    case DSConstants.UINT64: // these won't work, would have
                                                // to use BigInteger arith here
                    case DSConstants.LEUINT64:
                        throw new InternalError(
                                "I do not support 64bit lookahead, this should have been checked");
                }

                out.print(indent + "    " + latype + " " + la + " = ");
                readBuiltinType(tla.getKind());
                out.println();

                if (signexp != null)
                    out.println(indent + "    " + la + " = ((" + la + ") & "
                            + signexp + "); // prevent sign expansion");

                out
                        .println(indent
                                + "    __in.setBitPosition(__fpos);  // undo lookahead");
                if (Main.debugoutput)
                {
                    out.println(indent
                            + "    System.out.println(\"lookahead is \" + "
                            + la + ");");
                }

                out.println(indent + "    switch(" + la + ") {");
                RangeMap map = tla.getRangeMap();
                // do equals first
                Iterator equals = map.keySet().iterator();
                while (equals.hasNext())
                {
                    RangeMap.Range r = (RangeMap.Range) equals.next();
                    if (!r.isNumber())
                        continue;
                    out.println(indent + "    case (int)" + r.getLower() + ":");
                    Field field = (Field) map.get(r);
                    readField(field, type, excNum, indent + "    ");
                    out.println(indent + "        throw __exc_" + excNum + ";");
                    out.println(indent + "      }");
                    out.println(indent + "      break;");
                    excNum++;
                }
                // then do ranges
                out
                        .println(indent
                                + "    default:     // now emit the remaining ranges, if any");
                String lacmp = "__lacmp";
                out.println(indent + "      " + lacmptype + " " + lacmp + " = "
                        + la + ";");
                if (signexp2 != null)
                    out.println(indent + "      " + lacmp + " = ((" + lacmp
                            + ") & " + signexp2
                            + "); // prevent sign expansion");
                Iterator ranges = map.keySet().iterator();
                boolean first = true;
                while (ranges.hasNext())
                {
                    RangeMap.Range r = (RangeMap.Range) ranges.next();
                    if (r.isNumber())
                        continue;
                    if (!first)
                        out.println(indent + "      else");
                    first = false;
                    out.println(indent + "      if ((" + r.getLower() + "L <= "
                            + lacmp + ") && (" + lacmp + " < " + r.getUpper()
                            + "L)) {");
                    Field field = (Field) map.get(r);
                    readField(field, type, excNum, indent + "      ");
                    out.println(indent + "          throw __exc_" + excNum
                            + ";");
                    out.println(indent + "        } // end try/catch");
                    out.println(indent + "        break;");
                    out.println(indent + "      } // endif " + r);
                    excNum++;
                }
                out.println(indent + "      throw new " + IO_EXCEPTION
                        + "(\"no match for lookahead=\" + " + la + ");");
                out.println(indent + "    } // end of switch for lookahead");
            }
        }
    }

   
    
    /**
     * Emit constructors for union of form (type value, int choice).
     */
    void emitUnionConstructors(CompoundType type, String indent)
    {
    	
        out.println();
        int j = 0;
        for (Iterator i = type.getFields(); i.hasNext(); j++)
        {
            Field f = (Field) i.next();
            out.println(indent + "  static final int CHOICE_" + f.getName()
                    + " = " + j + ";");
        }
        out.println(indent + "  int " + CHOICETAG + ";");
        out.println();
        out.println(indent + "  public " + type.getName()
                + "() { /* default constructor */ " + CHOICETAG + " = -1; }");
        out.println();

        // I don't think I need those, do I?
        // people should just use the default constructor + set methods (!!?)
        if (false)
        {
            for (Iterator i = armName2armType.entrySet().iterator(); i
                    .hasNext();)
            {
                Map.Entry e = (Map.Entry) i.next();
                String armName = (String) e.getKey();
                String armType = (String) e.getValue();
                out.print(indent + "  " + type.getName() + "(");
                out.println(armType + " " + armName + ", int " + CHOICETAG
                        + ") {");
                out.println(indent + "    this." + armName + " = " + armName
                        + ";");
                out.println(indent + "    this." + CHOICETAG + " = "
                        + CHOICETAG + ";");
                out.println(indent + "  }");
                out.println();
            }
        }
    }

    void emitUnionAccessors(CompoundType type, String indent)
    {
        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            TypeInterface ftype = f.getType();
            if (ftype instanceof CompoundType
                    && ((CompoundType) ftype).isEmpty())
            {
                continue;
            }

            String fname = f.getName();
            String mname = makeAccessor(fname);

            out.println(indent + "  public " + printFieldType(f) + " get"
                    + mname + "() throws " + IO_EXCEPTION + " {");
            out.println(indent + "    if (" + CHOICETAG + " != CHOICE_" + fname
                    + ") {");
            out.println(indent + "       throw new " + IO_EXCEPTION + "(\""
                    + CHOICETAG + " = \" + " + CHOICETAG
                    + " + \" != \" + CHOICE_" + fname + ");");
            out.println(indent + "    }");
            String cast = "";
            if (ftype instanceof TypeInstantiation)
            {
                ftype = ((TypeInstantiation) ftype).baseType;
            }
            if (ftype instanceof ArrayType || ftype instanceof CompoundType)
            {
                cast = "(" + printType(ftype) + ")";
            }
            out.println(indent + "    return " + cast
                    + fieldName2armName.get(fname) + ";");
            out.println(indent + "  }");

            out.println(indent + "  public void set" + mname + "("
                    + printFieldType(f) + " " + fname + ") {");
            out.println(indent + "    this." + fieldName2armName.get(fname)
                    + " = " + fname + ";");
            out.println(indent + "    this." + CHOICETAG + " = CHOICE_" + fname
                    + ";");
            out.println(indent + "  }");

            out.println(indent + "  public boolean is" + mname + "() {");
            out.println(indent + "    return " + CHOICETAG + " == CHOICE_"
                    + fname + ";");
            out.println(indent + "  }");
            out.println();
        }
    }

    void emitUnionFieldDefinitions(CompoundType type, String indent)
    {
        fieldName2armName = new HashMap();
        armName2armType = new HashMap();

        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            TypeInterface ftype = f.getType();
            if (ftype instanceof ArrayType)
            {
                if (!fieldName2armName.containsValue("array_choice"))
                {
                    out.println(indent + "  Array array_choice;");
                    armName2armType.put("array_choice", "Array");
                }
                fieldName2armName.put(f.getName(), "array_choice");
            }
            else if (ftype instanceof BuiltinType || ftype instanceof SetType)
            {
                String sftype = printFieldType(f);
                if (!fieldName2armName.containsValue(sftype + "_choice"))
                {
                    out.println(indent + "  " + sftype + " " + sftype
                            + "_choice;");
                    armName2armType.put(sftype + "_choice", sftype);
                }
                fieldName2armName.put(f.getName(), sftype + "_choice");
            }
            else if (ftype instanceof StringType)
            {
                if (!fieldName2armName.containsValue("string_choice"))
                {
                    out.println(indent + "  String string_choice;");
                    armName2armType.put("string_choice", "String");
                }
                fieldName2armName.put(f.getName(), "string_choice");
            }
            else
            {
                if (!fieldName2armName.containsValue("object_choice"))
                {
                    out.println(indent + "  Object object_choice;");
                    armName2armType.put("object_choice", "Object");
                }
                fieldName2armName.put(f.getName(), "object_choice");
            }
        }
        ctype2armNameMapping.put(type, fieldName2armName);
        ctype2armTypeMapping.put(type, armName2armType);
    }

    HashMap getArmNameMapping(CompoundType ctype)
    {
        return (HashMap) ctype2armNameMapping.get(ctype);
    }

    HashMap getArmTypeMapping(CompoundType ctype)
    {
        return (HashMap) ctype2armTypeMapping.get(ctype);
    }

    void emitStructWrite(CompoundType type, String indent)
    {
        indent += "  ";
        out.println(indent + "public void write(BitArrayStreamWriter"
                + " __out, " + CALL_CHAIN_TYPE + " __cc) throws "
                + IO_EXCEPTION + " {");

        out.println(indent + "  __cc.push(" + "\"" + printType(type)
                + "\", this);");
        int bitfield_counter = 0;
        String currentBitfield = null;

        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            TypeInterface ftype = f.getType();
            String fname = f.getName();
            emitCheckFieldCondition(indent + "  ", f, fname, type);
            
            Node opt = f.getOptionalClause();
            if (opt != null)
            {
                indent += "    ";
                out.print(indent + "if (");
                emitCheckFieldOptional("", f, fname, type);
                out.println(")");
                out.println(indent + "{");
                if (ftype instanceof BuiltinType)
                {
                    out.println(indent + "    __has" + makeAccessor(fname)
                            + " = true;");
                }
            }

            if (ftype instanceof CompoundType || ftype instanceof ArrayType
                    || ftype instanceof TypeInstantiation)
            {
                out.println(indent + "  " + fname + ".write(__out, __cc);");
            }
            else if (ftype instanceof StringType)
            {
                out.println(indent + "  __out.writeUTF(" + fname + ");");
            }
            else
            {
            	BuiltinType btype = BuiltinType.getBuiltinType(ftype);
            	 Context ctxt = type.getScope();
            	
            	  if (f.isBitField())
                  {
            		  BitFieldType bftype = (BitFieldType) btype;
            		  out.print(indent);
            		  writeBitFieldType(bftype, f.getCompound(), ctxt, fname);
            		  out.println(";");
                  }else{
                	  
                	  
                	  out.print(indent + "  __out.");
                	  writeBuiltinType(btype.kind,fname);
                  }
            }
            
            if (opt != null){
            	out.println(indent + "}");
            }
        }
        if (currentBitfield != null)
        {
            out.println(indent + "  __out.write(" + currentBitfield + ");");
        }
        out.println(indent + "__out.flush_all();");
        out.println(indent + "  __cc.pop();");
        out.println(indent + "}");
    }

    /**
     * returns symbol or formula for array length or null if array is
     * variable-length
     */
    String computeLengthExpression(Context ctxt, CompoundType ctype,
            ArrayType atype)
    {
        if (atype.upperBound == null)
            return "-1";

        JavaExpressionEmitter em;
        em = new JavaExpressionEmitter(ctype, ctxt);
        ExpressionTypeCheckVisitor jvis;
        jvis = new ExpressionTypeCheckVisitor(ctype, ctxt, em);
        atype.upperBound.accept(jvis);
        String ub = em.result();
        if (atype.lowerBound != null)
        {
            ub = "(" + ub + ") - (" + getLowerBound(atype, ctxt, ctype) + ")";
        }
        return ub;
    }

    /*
     * get lower bound expression for a given array type hashes expressions, if
     * not found, computes it for context and ctype BUG: will always return the
     * first expression without checking whether ctxt/ctype remained the same
     */
    static String getLowerBound(ArrayType atype, Context ctxt,
            CompoundType ctype)
    {
        String lowerBound = (String) lowerBoundHash.get(atype);
        if (lowerBound == null)
        {
            JavaExpressionEmitter em;
            ExpressionTypeCheckVisitor jvis;
            em = new JavaExpressionEmitter(ctype, ctxt);
            jvis = new ExpressionTypeCheckVisitor(ctype, ctxt, em);
            atype.lowerBound.accept(jvis);
            lowerBound = em.result();
            lowerBoundHash.put(atype, lowerBound);
        }
        return lowerBound;
    }

    // maps ArrayType to String for lowerBound
    // this shouldn't be static, but passed on to JavaExpressionEmitters
    // where necessary
    static HashMap lowerBoundHash = new HashMap();

    private void emitArrayInput(String indent, Field f, String fname,
            CompoundType ctype)
    {
        TypeInterface ftype = f.getType();
        TypeInterface etype = ((ArrayType) ftype).getElementType();
        String len = computeLengthExpression(ctype.getScope(), f.getCompound(),
                (ArrayType) ftype);
        try
        {
            // test if element type is builtin or enumerated based on builtin
            BuiltinType builtInType = BuiltinType.getBuiltinType(etype);
            if (builtInType instanceof BitFieldType)
            {
                BitFieldType bfType = (BitFieldType) builtInType;
                if (bfType.isVariable())
                {
                    // This exception gets us to the vector input branch below.
                    // @TODO clean this up
                    throw new ClassCastException();
                }
                out.println(indent + fname + " = new BitFieldArray(__in," + len
                        + ", " + bfType.getLength() + ");");

            }
            else
            {
                // should we handle uint8 v[] : v[_] ... somehow???

                // handles primitive arrays well, but doesn't handle
                // enumerated/bitmasks arrays so well.
                out
                        .println(indent + "    if (" + len
                                + " > Integer.MAX_VALUE)");
                out.println(indent + "      throw new " + IO_EXCEPTION
                        + "(\"array length does not fit in int\");");
                out.println(indent + "    " + fname + " = new "
                        + printFieldType(f) + "(__in, (int)(" + len + "));");
            }
        }
        catch (ClassCastException _)
        {
            // element type is a compound type
            out.println(indent + "    {");
            Scope oscope, nscope = new Scope(oscope = ctype.getScope());
            try
            {
                nscope.setSymbol(f.getName() + "$index", new Parameter("i",
                        IntegerType.integerType));
                ctype.setScope(nscope);
                String ind = indent + "      ";
                if (!len.equals("-1"))
                {
                    out.println(ind + "Vector v = new Vector((int)(" + len
                            + ")); // XXX make sure cast doesn't narrow");
                    out.println(ind + "for (int i = 0; i < (" + len
                            + "); i++) {");
                    out.print(ind + "  v.addElement(");
                    emitNewObject(ctype, etype);
                    out.println(");");
                    out.println(ind + "}");
                }
                else
                {
                    out.println(ind + "Vector v = new Vector();");
                    out.println(ind + "long __afpos = 0;");
                    out.println(ind + "try {");
                    out.println(ind + "  while (true) {");
                    out.println(ind + "    __afpos = __in.getBitPosition();");
                    out.print(ind + "    v.addElement(");
                    emitNewObject(ctype, etype);
                    out.println(");");
                    out.println(ind + "  }");
                    out.println(ind + "} catch (" + IO_EXCEPTION + " __e) {");
                    if (Main.debugoutput)
                    {
                        out.println(ind + "  System.out.println(\"" + ind
                                + "read \" + v.size() + \" entries of "
                                + ((CompoundType) etype).getName()
                                + " then: \" + __e);");
                    }
                    out.println(ind + "  __in.setBitPosition(__afpos);");
                    out.println(ind + "}");
                }
                out.println(ind + fname + " = new ObjectArray(v);");
                out.println(indent + "    }");
            }
            finally
            {
                ctype.setScope(oscope);
            }
        }
    }

    private void emitStringTypeInput(String indent, Field f, String fname,
            Context ctxt)
    {

        out.println(indent + fname + " = Util.readZTString(__in);");
    }

    private void emitBuiltinTypeInput(String indent, Field f, String fname,
            Context ctxt)
    {
        TypeInterface ftype = f.getType();
        indent += "    ";

        if (ftype instanceof StringType)
        {
            emitStringTypeInput(indent, f, fname, ctxt);
            return;
        }

        BuiltinType btype = BuiltinType.getBuiltinType(ftype);

        if (f.isBitField())
        {
            BitFieldType bftype = (BitFieldType) btype;
            out.print(indent + fname + " = ");
            readBitFieldType(bftype, f.getCompound(), ctxt);
            out.println(";");
            return;
        }

        // default case: integer types
        out.print(indent + fname + " = ");
        readBuiltinType(btype.kind);
        out.println();
    }

    
    private void writeBitFieldType(BitFieldType bftype, CompoundType compound,
            Context ctxt, String fname)
    {
        if (bftype.isVariable())
        {
            JavaExpressionEmitter em;
            em = new JavaExpressionEmitter(compound, ctxt);
            ExpressionTypeCheckVisitor jvis;
            jvis = new ExpressionTypeCheckVisitor(compound, ctxt, em);
            bftype.varLength.accept(jvis);
            String length = em.result();

            out.print("__out.writeBigInteger(" + fname + "," + length + ")");
        }
        else
        {
            if (bftype.length < 64)
            {
                out.println("__out.writeBits("
                        + fname + "," + bftype.length + ");");
            }
            else
            {
                out.print("__out.writeBigInteger(" + fname + "," + bftype.length + ")");
            }
        }
    }
    
    private void readBitFieldType(BitFieldType bftype, CompoundType compound,
            Context ctxt)
    {
        if (bftype.isVariable())
        {
            JavaExpressionEmitter em;
            em = new JavaExpressionEmitter(compound, ctxt);
            ExpressionTypeCheckVisitor jvis;
            jvis = new ExpressionTypeCheckVisitor(compound, ctxt, em);
            bftype.varLength.accept(jvis);
            String length = em.result();

            out.print("__in.readBigInteger(" + length + ")");
        }
        else
        {
            if (bftype.length < 64)
            {
                out.println("(" + printType(bftype) + ") __in.readBits("
                        + bftype.length + ");");
            }
            else
            {
                out.print("__in.readBigInteger(" + bftype.length + ")");
            }
        }
    }

    
    private void writeBuiltinType(int kind,String fname)
    {
    
    	
        switch (kind)
        {
            case DSConstants.INT8:
            	out.print("writeByte(" + fname + ");");
                break;

            case DSConstants.UINT8:
                out.print("writeUnsignedByte(" + fname + ");");
                break;

            case DSConstants.INT16:
            	out.print("writeShort(" + fname + ");");
                break;

            case DSConstants.UINT16:
                out.print("writeUnsignedShort(" + fname + ");");
                break;

            case DSConstants.LEINT16:
            case DSConstants.LEUINT16:
                out.print("writeShort(Util.leShort(" + fname + "));");
                break;

            case DSConstants.INT32:
            	out.print("writeInt(" + fname + ");");
                break;

            case DSConstants.UINT32:
                out.print("writeUnsignedInt(" + fname + ");");
                break;

            case DSConstants.LEINT32:
            case DSConstants.LEUINT32:
                out.print("writeInt(Util.leInt(" + fname + "));");
                break;

            case DSConstants.INT64:
                out.print("writeLong(" + fname + ");");
                break;

            case DSConstants.UINT64:
                out.print("writeBigInteger(" + fname + ",64);");
                break;

            case DSConstants.LEINT64:
            case DSConstants.LEUINT64:
                out.print("writeLong(Util.leLong(" + fname + "));");
                break;

            default:
                throw new InternalError("bad type kind=" + kind);
        }
    }

    
    private void readBuiltinType(int kind)
    {
        switch (kind)
        {
            case DSConstants.INT8:
                out.print("__in.readByte();");
                break;

            case DSConstants.UINT8:
                out.print("(short) __in.readUnsignedByte();");
                break;

            case DSConstants.INT16:
                out.print("__in.readShort();");
                break;

            case DSConstants.UINT16:
                out.print("__in.readUnsignedShort();");
                break;

            case DSConstants.LEINT16:
            case DSConstants.LEUINT16:
                out.print("Util.leShort(__in.readShort());");
                break;

            case DSConstants.INT32:
                out.print("__in.readInt();");
                break;

            case DSConstants.UINT32:
                out.print("__in.readUnsignedInt();");
                break;

            case DSConstants.LEINT32:
            case DSConstants.LEUINT32:
                out.print("Util.leInt(__in.readInt());");
                break;

            case DSConstants.INT64:
                out.print("__in.readLong();");
                break;

            case DSConstants.UINT64:
                out.print("__in.readBigInteger(64);");
                break;

            case DSConstants.LEINT64:
            case DSConstants.LEUINT64:
                out.print("Util.leLong(__in.readLong());");
                break;

            default:
                throw new InternalError("bad type kind=" + kind);
        }
    }

    private String protect(String input)
    {
        StringBuffer output = new StringBuffer();
        for (int i = 0; i < input.length(); i++)
        {
            char c;
            switch (c = input.charAt(i))
            {
                case '\n':
                    output.append("\\n");
                    break;
                case '\t':
                    output.append("\\t");
                    break;
                case '\\':
                case '"':
                    output.append("\\" + c);
                    break;

                default:
                    output.append(c);
            }
        }
        return output.toString();
    }

    /**
     * for a given field, emit the code to check that this field's value
     * complies with the initialization and field conditions
     */
    private void emitCheckFieldCondition(String indent, Field f, String fname,
            CompoundType ctype)
    {
        JavaExpressionEmitter em;
        em = new JavaExpressionEmitter(ctype);
        em.fieldAccess(f);
        String facc = em.result();

        /* check field initializer */
        if (f.getInitializer() != null)
        {
            ExpressionTypeCheckVisitor jvis;

            em = new JavaExpressionEmitter(ctype);
            jvis = new ExpressionTypeCheckVisitor(f.getCompound(), ctype
                    .getScope(), em);
            f.getInitializer().accept(jvis);

            out
                    .println(indent + "if (" + facc + " != (" + em.result()
                            + ")) {");
            if (Main.shortexceptions)
            {
                out.println(indent + "  throw new IOException();");
            }
            else
            {
                out.println(indent + "  throw new IOException(\"" + fname
                        + ": \" + (" + facc + ") + \" != "
                        + protect(Main.printNode(f.getInitializer())) + "\");");
            }
            out.println(indent + "}");
        }

        /* check field condition */
        if (f.getCondition() != null)
        {
            ExpressionTypeCheckVisitor jvis;
            em = new JavaExpressionEmitter(ctype);
            jvis = new ExpressionTypeCheckVisitor(f.getCompound(), ctype
                    .getScope(), em);
            f.getCondition().accept(jvis);
            out.println(indent + "if (!(" + em.result() + ")) {");
            if (Main.shortexceptions)
            {
                out.println(indent + "  throw new IOException();");
            }
            else
            {
                out.println(indent + "  throw new IOException(\""
                        + protect(Main.printNode(f.getCondition()))
                        + " does not hold \");");
            }
            out.println(indent + "}");
        }

        /**
         * check that if we know an array's length, the actual length matches
         */
        if (f.getType() instanceof ArrayType)
        {
            ArrayType atype = (ArrayType) f.getType();
            String len = computeLengthExpression(ctype.getScope(), f
                    .getCompound(), atype);
            if (!len.equals("-1"))
            {
                out.println(indent + "if ((" + len + ") != " + fname
                        + ".length()) {");
                if (Main.shortexceptions)
                {
                    out.println(indent + "  throw new IOException();");
                }
                else
                {
                    out.println(indent
                            + "  throw new IOException(\"actual length of "
                            + fname + " (=\" + " + fname
                            + ".length() + \") != required length (=\" + ("
                            + len + ") + \")\");");
                }
                out.println(indent + "}");
            }
        }

        /* check that it's a member of a bitmask or enum */
        if (f.getType() instanceof SetType)
        {
            SetType stype = (SetType) f.getType();
            out.println(indent + "if (!" + CHECKTHAT + ".isValid_"
                    + JavaBytesEmitMembershipTests.getFullPath(stype.getCompound())
                    + stype.getName() + "(" + facc + ")) {");
            if (Main.shortexceptions)
            {
                out.println(indent + "  throw new IOException();");
            }
            else
            {
                out.println(indent + "  throw new IOException(" + facc
                        + " + \" is not a valid " + stype.getName() + "\");");
            }
            out.println(indent + "}");
        }
    }

    private void emitCheckFieldOptional(String indent, Field f, String fname,
            CompoundType ctype)
    {
        JavaExpressionEmitter em;
        em = new JavaExpressionEmitter(ctype);
        em.fieldAccess(f);

        /* check field condition */
        if (f.getOptionalClause() != null)
        {
            ExpressionTypeCheckVisitor jvis;
            em = new JavaExpressionEmitter(ctype);
            jvis = new ExpressionTypeCheckVisitor(f.getCompound(), ctype
                    .getScope(), em);
            f.getOptionalClause().accept(jvis);
            out.print(em.result());
        }
    }

    private void emitObjectInput(String indent, String fname,
            TypeInterface ftype, CompoundType ctype)
    {
        if (!((ftype instanceof CompoundType) && ((CompoundType) ftype)
                .isEmpty()))
        {
            out.print(indent + "    " + fname + " = ");
            emitNewObject(ctype, ftype);
            out.println(";");
        }
    }

    private void emitNewObject(CompoundType ct, TypeInterface ftype)
    {
        if (ftype instanceof CompoundType)
        {
            out.print("new " + printType(ftype) + "(__in, __cc)");
        }
        else if (ftype instanceof TypeInstantiation)
        {
            TypeInstantiation ti = (TypeInstantiation) ftype;
            if (!(ti.baseType instanceof CompoundType))
            {
                throw new InternalError("basetype not a compound types!?");
            }
            CompoundType ctype = (CompoundType) ti.baseType;

            out.print("new " + printType(ti.baseType) + "(__in, __cc");
            for (int i = 0; i < ti.typeParameters.size(); i++)
            {
                Node expr = (Node) ti.typeParameters.elementAt(i);
                out.print(", ");
                JavaExpressionEmitter em;
                em = new JavaExpressionEmitter(ct, ct.getScope());
                expr.accept(new ExpressionTypeCheckVisitor(ct, ct.getScope(),
                        em));
                em.castTo(IntegerType.integerType,
                        ((Parameter) ctype.parameters.elementAt(i)).getType());
                out.print(em.result());
            }
            out.print(")");
        }
        else if (ftype instanceof StringType)
        {
            out.print("Util.readZTString(__in)");
        }
        else if (ftype instanceof BitFieldType)
        {
            readBitFieldType((BitFieldType) ftype, ct, ct.getScope());
            // out.print("__in.readBigInteger(" + numBits +")");
        }
    }

    void emitLabelExpression(Field f, CompoundType type, String indent)
    {
        Node label = f.getLabel();
        Node globalLabel = f.getGlobalLabel();
        if (label == null)
        {
            return;
        }
        ExpressionTypeCheckVisitor jvis;
        JavaExpressionEmitter em;
        String prefix = "this";

        if (globalLabel != null)
        {
            em = new JavaExpressionEmitter(type, type.getScope());
            jvis = new ExpressionTypeCheckVisitor(type, type.getScope(), em);
            f.getGlobalLabel().accept(jvis);
            prefix = em.result();
        }

        em = new JavaExpressionEmitter(type, type.getScope());
        jvis = new ExpressionTypeCheckVisitor(type, type.getScope(), em);
        f.getLabel().accept(jvis);
        out.println(indent + "    __in.setBitPosition(" + prefix
                + ".__fpos + 8*(" + em.result() + "));");
        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + " seeking to \" + (" + prefix + ".__fpos + "
                    + em.result() + ") + \" offset from \" + __fpos);");
        }
    }

    void emitStructInputConstructor(CompoundType type, String indent)
    {
        indent += "  ";
        out.println(indent + "  __fpos = __in.getBitPosition();");
        out.println(indent + "  try {");
        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + type.getName()
                    + " (struct) might start here; fpos=\" + __fpos);");
        }
        Context ctxt = type.getScope();

        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            TypeInterface ftype = f.getType();
            String fname = f.getName();

            emitLabelExpression(f, type, indent);

            Node opt = f.getOptionalClause();
            String oldIndent = indent;
            if (opt != null)
            {
                indent += "    ";
                out.print(indent + "if (");
                emitCheckFieldOptional("", f, fname, type);
                out.println(")");
                out.println(indent + "{");
                if (ftype instanceof BuiltinType)
                {
                    out.println(indent + "    __has" + makeAccessor(fname)
                            + " = true;");
                }
            }

            if (ftype instanceof CompoundType
                    || ftype instanceof TypeInstantiation)
            {
                emitObjectInput(indent, fname, ftype, type);
            }
            else if (ftype instanceof ArrayType)
            {
                emitArrayInput(indent, f, fname, type);
            }
            else
            {
                emitBuiltinTypeInput(indent, f, fname, ctxt);
            }

            if (opt != null)
            {
                out.println(indent + "}");
                indent = oldIndent;
            }
            emitCheckFieldCondition(indent + "    ", f, fname, type);
        }

        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + type.getName() + " seen!\");");
        }
        out.println(indent + "  } catch (" + IO_EXCEPTION + " __e1) {");
        if (Main.debugoutput)
        {
            out.println(indent + "    System.out.println(\"" + indent
                    + type.getName() + " failed:\" + __e1);");
        }
        out.println(indent + "    __in.setBitPosition(__fpos);");
        out.println(indent + "    throw __e1;");
        out.println(indent + "  }");
    }

    void emitStructConstructor(CompoundType type, String indent)
    {
    	
    	out.println(indent + "  public " + type.getName() 
				+ "() { /* default constructor - structure type */ }");
		out.println(); 
    	
        // print type name
        out.print(indent + "  " + type.getName() + "(");

        // print constructor parameter list
        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            out.print(printFieldType(f) + " ");
            out.print(f.getName());
            if (i.hasNext())
            {
                out.print(",");
            }
        }
        out.println(") {");
        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            out.println(indent + "    this." + f.getName() + " = "
                    + f.getName() + ";");
        }
        out.println(indent + "  }");
    }

    static boolean useJavaBeansStyle = true;

    public static String makeAccessor(String name)
    {
        if (useJavaBeansStyle)
        {
            return name.substring(0, 1).toUpperCase()
                    + name.substring(1, name.length());
        }
        else
        {
            throw new Error("don't know what style to use");
        }
    }

    void emitStructFieldDefinitions(CompoundType type, String indent)
    {
        for (Iterator i = type.getFields(); i.hasNext();)
        {
            Field f = (Field) i.next();
            String fname = f.getName();
            String mname = makeAccessor(fname);
            
                if(f.getInitializer() != null){
				
				ExpressionTypeCheckVisitor jvis;
				JavaExpressionEmitter em;   
				em = new JavaExpressionEmitter(type);
				
				jvis = new ExpressionTypeCheckVisitor(f.getCompound(), type.getScope(), em);
				f.getInitializer().accept(jvis);
				
				String facc = em.result();
				
				if(printFieldType(f) == "String" ){
					out.println(indent + "   public " + printFieldType(f) + " " + fname + " = new String(" + facc + ");");
					
				}else if(printFieldType(f) == "byte" ){
					// Iliminate a "L" charachter, It is of no use at all at this moment.
					facc = facc.substring(0,facc.length() - 1);
					out.println(indent + "   public " + printFieldType(f) + " " + fname + " = (byte)" + facc + ";");
					
				}else if(printFieldType(f) == "long" ){
					out.println(indent + "   public " + printFieldType(f) + " " + fname + " = " + facc + ";");
					
				}else{
					// Iliminate a "L" charachter, It is of no use at all at this moment.
					facc = facc.substring(0,facc.length() - 1);
					out.println(indent + "   public " + printFieldType(f) + " " + fname + " = " + facc + ";");
				}
				
			}else{
				if( f.getType() instanceof ArrayType){
					//? I make a instance in generated file by javaEmitter.java for easy to use, but It shoud be tested in a view of side effect.
					out.println(indent + "   public " + printFieldType(f) + " " + fname + " = new " + printFieldType(f) + "();");
					
				}else out.println(indent + "  public " + printFieldType(f) + " " + fname + ";");
			}
            
            if (f.getOptionalClause() != null)
            {
                String condition;
                if (isJavaTypeBuiltIn(f.getType()))
                {
                    out.println(indent + "  boolean __has" + mname
                            + " = false;");
                    condition = "__has" + mname;
                }
                else
                {
                    condition = "(" + fname + " != null)";
                }
                out.println(indent + "  public boolean has" + mname
                        + "() { return " + condition + "; }");
            }
//            out.println(indent + "  " + printFieldType(f) + " " + fname + ";");
            out.println(indent + "  public " + printFieldType(f) + " get"
                    + mname + "() { return " + fname + "; }");
            out.println(indent + "  public void set" + mname + "("
                    + printFieldType(f) + " " + fname + ") { this." + fname
                    + " = " + fname + "; }");
            out.println();
        }
    }

    private boolean isJavaTypeBuiltIn(TypeInterface type)
    {
        TypeInterface baseType;
        if (type instanceof SetType)
        {
            baseType = ((SetType) type).type;
        }
        else
        {
            baseType = type;
        }
        boolean result = baseType instanceof BuiltinType;
        if (result)
        {
            if (baseType instanceof BitFieldType)
            {
                BitFieldType bftype = (BitFieldType) baseType;
                if (bftype.isVariable())
                {
                    // Java type is BigInteger
                    result = false;
                }
                else
                {
                    // Java type is BigInteger for length >= 64
                    result = (bftype.length < 64);
                }
            }
        }
        return result;
    }

    static String printFieldType(Field f)
    {
        TypeInterface ftype = f.getType();
        if (ftype instanceof TypeInstantiation)
        {
            ftype = ((TypeInstantiation) ftype).baseType;
        }
        return printType(ftype);
    }

    static String fullyQualifiedTypeName(CompoundType fctype)
    {
        String res = JavaBytesEmitter.printTypeBuiltins(fctype);

        // not exactly very efficient...
        while (fctype.getParent() != null
                && (fctype = fctype.getParent()).getParent() != null)
        {
            res = JavaBytesEmitter.printTypeBuiltins(fctype) + "." + res;
        }
        return res;
    }

    public static String printType(TypeInterface type)
    {
        if (type instanceof CompoundType)
        {
            return fullyQualifiedTypeName((CompoundType) type);
        }
        else
        {
            return printTypeBuiltins(type);
        }
    }

    static private String printTypeBuiltins(TypeInterface type)
    {
        TypeInterface ftype = type;

        if (ftype instanceof ArrayType)
        {
            ArrayType atype = (ArrayType) ftype;
            TypeInterface etype = atype.getElementType();

            try
            {
                BuiltinType btype = BuiltinType.getBuiltinType(etype);
                if (btype instanceof BitFieldType)
                {
                    BitFieldType bftype = (BitFieldType) btype;
                    return (bftype.isVariable() ? "ObjectArray"
                            : "BitFieldArray");
                }
                switch (btype.kind)
                {
                    case DSConstants.INT8:
                    case DSConstants.UINT8:
                        return "ByteArray";

                    case DSConstants.INT16:
                    case DSConstants.LEINT16:
                    case DSConstants.UINT16:
                    case DSConstants.LEUINT16:
                        return "ShortArray";

                    case DSConstants.INT32:
                    case DSConstants.LEINT32:
                    case DSConstants.UINT32:
                    case DSConstants.LEUINT32:
                        return "IntArray";

                    case DSConstants.INT64:
                    case DSConstants.LEINT64:
                    case DSConstants.UINT64:
                    case DSConstants.LEUINT64:
                        return "LongArray";

                    default:
                        throw new InternalError("bad type found");
                }
            }
            catch (ClassCastException _)
            {
                return "ObjectArray /* of " + etype + " */";
            }
        }
        else if (ftype instanceof BuiltinType || ftype instanceof SetType)
        {
            BuiltinType btype = BuiltinType.getBuiltinType(ftype);
            return mapKindToType(btype.kind);
        }
        if (ftype instanceof StringType)
        {
            return "String";
        }
        else
        {
            return ftype.toString();
        }
    }

    static String mapKindToType(int kind)
    {
        switch (kind)
        {
            case DSConstants.INT8:
                return "byte";

            case DSConstants.UINT8:
            case DSConstants.INT16:
            case DSConstants.LEINT16:
                return "short";

            case DSConstants.UINT16:
            case DSConstants.LEUINT16:
            case DSConstants.INT32:
            case DSConstants.LEINT32:
                return "int";

            case DSConstants.UINT32:
            case DSConstants.LEUINT32:
            case DSConstants.INT64:
            case DSConstants.LEINT64:
                return "long";

            case DSConstants.UINT64:
            case DSConstants.LEUINT64:
            case DSConstants.BIT:
                return "BigInteger";

            default:
                throw new InternalError("bad type found " + kind);
        }
    }
}
