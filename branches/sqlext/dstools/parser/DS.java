/* Generated By:JavaCC: Do not edit this line. DS.java */
package datascript.parser;

import java.util.*;
import datascript.syntaxtree.*;
import java.util.Vector;


public class DS implements DSConstants {
   static Hashtable slcomments = new Hashtable();
   public static void recordSingleLineComment(int ln,String cmt)
   {
      slcomments.put(new Integer(ln),cmt);
   }

  final public TranslationUnit TranslationUnit() throws ParseException {
    trace_call("TranslationUnit");
    try {
   DeclarationList n0;

   {
   }
      n0 = DeclarationList();
     {if (true) return new TranslationUnit(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TranslationUnit");
    }
  }

  final public DeclarationList DeclarationList() throws ParseException {
    trace_call("DeclarationList");
    try {
   NodeListOptional n0 = new NodeListOptional();
   Declaration n1;

   {
   }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
        case BIG:
        case BIT:
        case LITTLE:
        case UINT8:
        case UINT16:
        case UINT32:
        case UINT64:
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case ENUM:
        case BITMASK:
        case CONDITION:
        case UNION:
        case DATABASE:
        case TABLE:
        case SQLINTEGER:
        case SQLTEXT:
        case SIZEOF:
        case FORALL:
        case STRING:
        case INDEX:
        case CONSTRAINT:
        case PLUS:
        case MINUS:
        case TILDE:
        case BANG:
        case FLOATING_POINT_LITERAL:
        case INTEGER_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case 86:
        case 89:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        n1 = Declaration();
        n0.addNode(n1);
      }
     n0.nodes.trimToSize();
     {if (true) return new DeclarationList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DeclarationList");
    }
  }

  final public Declaration Declaration() throws ParseException {
    trace_call("Declaration");
    try {
   NodeChoice n0;
   NodeSequence n1;
   FieldDefinition n2;
   NodeToken n3;
   Token n4;
   ConditionDefinition n5;
   NodeSequence n6;
   ConstDeclaration n7;
   NodeToken n8;
   Token n9;
   NodeSequence n10;
   SqlFieldDefinition n11;
   NodeToken n12;
   Token n13;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIG:
      case BIT:
      case LITTLE:
      case UINT8:
      case UINT16:
      case UINT32:
      case UINT64:
      case INT8:
      case INT16:
      case INT32:
      case INT64:
      case ENUM:
      case BITMASK:
      case UNION:
      case DATABASE:
      case TABLE:
      case SQLINTEGER:
      case SQLTEXT:
      case SIZEOF:
      case FORALL:
      case STRING:
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
      case 89:
        n1 = new NodeSequence(2);
        n2 = FieldDefinition();
        n1.addNode(n2);
        n4 = jj_consume_token(83);
               n3 = JTBToolkit.makeNodeToken(n4);
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
        break;
      case CONDITION:
        n5 = ConditionDefinition();
        n0 = new NodeChoice(n5, 1);
        break;
      case CONST:
        n6 = new NodeSequence(2);
        n7 = ConstDeclaration();
        n6.addNode(n7);
        n9 = jj_consume_token(83);
               n8 = JTBToolkit.makeNodeToken(n9);
        n6.addNode(n8);
        n0 = new NodeChoice(n6, 2);
        break;
      case INDEX:
      case CONSTRAINT:
        n10 = new NodeSequence(2);
        n11 = SqlFieldDefinition();
        n10.addNode(n11);
        n13 = jj_consume_token(83);
                n12 = JTBToolkit.makeNodeToken(n13);
        n10.addNode(n12);
        n0 = new NodeChoice(n10, 3);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new Declaration(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Declaration");
    }
  }

  final public Label Label() throws ParseException {
    trace_call("Label");
    try {
   NodeOptional n0 = new NodeOptional();
   GlobalLabel n1;
   Expression n2;
   NodeToken n3;
   Token n4;

   {
   }
      if (jj_2_1(2147483647)) {
        n1 = GlobalLabel();
        n0.addNode(n1);
      } else {
        ;
      }
      n2 = Expression();
      n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new Label(n0,n2,n3);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Label");
    }
  }

  final public GlobalLabel GlobalLabel() throws ParseException {
    trace_call("GlobalLabel");
    try {
   Expression n0;
   NodeToken n1;
   Token n2;

   {
   }
      n0 = Expression();
      n2 = jj_consume_token(85);
             n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new GlobalLabel(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GlobalLabel");
    }
  }

  final public ConditionDefinition ConditionDefinition() throws ParseException {
    trace_call("ConditionDefinition");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeOptional n6 = new NodeOptional();
   NodeSequence n7;
   ParameterDefinition n8;
   NodeListOptional n9;
   NodeSequence n10;
   NodeToken n11;
   Token n12;
   ParameterDefinition n13;
   NodeToken n14;
   Token n15;
   NodeToken n16;
   Token n17;
   NodeListOptional n18 = new NodeListOptional();
   NodeSequence n19;
   ConditionExpression n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;

   {
   }
      n1 = jj_consume_token(CONDITION);
                    n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
      n5 = jj_consume_token(86);
            n4 = JTBToolkit.makeNodeToken(n5);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIG:
      case BIT:
      case LITTLE:
      case UINT8:
      case UINT16:
      case UINT32:
      case UINT64:
      case INT8:
      case INT16:
      case INT32:
      case INT64:
      case ENUM:
      case BITMASK:
      case UNION:
      case DATABASE:
      case TABLE:
      case SQLINTEGER:
      case SQLTEXT:
      case STRING:
      case IDENTIFIER:
      case 86:
      case 89:
        n9 = new NodeListOptional();
        n7 = new NodeSequence(2);
        n8 = ParameterDefinition();
        n7.addNode(n8);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 87:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
           n10 = new NodeSequence(2);
          n12 = jj_consume_token(87);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n10.addNode(n11);
          n13 = ParameterDefinition();
           n10.addNode(n13);
           n9.addNode(n10);
        }
        n9.nodes.trimToSize();
        n7.addNode(n9);
        n6.addNode(n7);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      n15 = jj_consume_token(88);
             n14 = JTBToolkit.makeNodeToken(n15);
      n17 = jj_consume_token(89);
             n16 = JTBToolkit.makeNodeToken(n17);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case FORALL:
        case PLUS:
        case MINUS:
        case TILDE:
        case BANG:
        case FLOATING_POINT_LITERAL:
        case INTEGER_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case 86:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        n19 = new NodeSequence(2);
        n20 = ConditionExpression();
        n19.addNode(n20);
        n22 = jj_consume_token(83);
                n21 = JTBToolkit.makeNodeToken(n22);
        n19.addNode(n21);
        n18.addNode(n19);
      }
     n18.nodes.trimToSize();
      n24 = jj_consume_token(90);
             n23 = JTBToolkit.makeNodeToken(n24);
     {if (true) return new ConditionDefinition(n0,n2,n4,n6,n14,n16,n18,n23);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionDefinition");
    }
  }

  final public ParameterDefinition ParameterDefinition() throws ParseException {
    trace_call("ParameterDefinition");
    try {
   TypeDeclaration n0;
   NodeToken n1;
   Token n2;

   {
   }
      n0 = TypeDeclaration();
      n2 = jj_consume_token(IDENTIFIER);
                     n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new ParameterDefinition(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParameterDefinition");
    }
  }

  final public ConditionExpression ConditionExpression() throws ParseException {
    trace_call("ConditionExpression");
    try {
   Expression n0;

   {
   }
      n0 = Expression();
     {if (true) return new ConditionExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionExpression");
    }
  }

  final public EnumDeclaration EnumDeclaration() throws ParseException {
    trace_call("EnumDeclaration");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   BuiltinType n5;
   NodeOptional n6 = new NodeOptional();
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   EnumItem n11;
   NodeListOptional n12 = new NodeListOptional();
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   EnumItem n16;
   NodeToken n17;
   Token n18;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENUM:
        n2 = jj_consume_token(ENUM);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case BITMASK:
        n4 = jj_consume_token(BITMASK);
                        n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n5 = BuiltinType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n8 = jj_consume_token(IDENTIFIER);
                        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      n10 = jj_consume_token(89);
             n9 = JTBToolkit.makeNodeToken(n10);
      n11 = EnumItem();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        n13 = new NodeSequence(2);
        n15 = jj_consume_token(87);
                n14 = JTBToolkit.makeNodeToken(n15);
        n13.addNode(n14);
        n16 = EnumItem();
        n13.addNode(n16);
        n12.addNode(n13);
      }
     n12.nodes.trimToSize();
      n18 = jj_consume_token(90);
             n17 = JTBToolkit.makeNodeToken(n18);
     {if (true) return new EnumDeclaration(n0,n5,n6,n9,n11,n12,n17);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EnumDeclaration");
    }
  }

  final public EnumItem EnumItem() throws ParseException {
    trace_call("EnumItem");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   ConstantExpression n6;

   {
   }
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 91:
        n3 = new NodeSequence(2);
        n5 = jj_consume_token(91);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
        n6 = ConstantExpression();
        n3.addNode(n6);
        n2.addNode(n3);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
     {if (true) return new EnumItem(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EnumItem");
    }
  }

  final public ConstDeclaration ConstDeclaration() throws ParseException {
    trace_call("ConstDeclaration");
    try {
   NodeToken n0;
   Token n1;
   TypeDeclaration n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   TypeValue n7;

   {
   }
      n1 = jj_consume_token(CONST);
                n0 = JTBToolkit.makeNodeToken(n1);
      n2 = TypeDeclaration();
      n4 = jj_consume_token(IDENTIFIER);
                     n3 = JTBToolkit.makeNodeToken(n4);
      n6 = jj_consume_token(91);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = TypeValue();
     {if (true) return new ConstDeclaration(n0,n2,n3,n5,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConstDeclaration");
    }
  }

  final public TypeValue TypeValue() throws ParseException {
    trace_call("TypeValue");
    try {
   NodeChoice n0;
   ConstantExpression n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   TypeValueList n5;
   NodeToken n6;
   Token n7;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
        n1 = ConstantExpression();
        n0 = new NodeChoice(n1, 0);
        break;
      case 89:
        n2 = new NodeSequence(3);
        n4 = jj_consume_token(89);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = TypeValueList();
        n2.addNode(n5);
        n7 = jj_consume_token(90);
               n6 = JTBToolkit.makeNodeToken(n7);
        n2.addNode(n6);
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new TypeValue(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeValue");
    }
  }

  final public TypeValueList TypeValueList() throws ParseException {
    trace_call("TypeValueList");
    try {
   TypeValue n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   TypeValue n5;

   {
   }
      n0 = TypeValue();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(87);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = TypeValue();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new TypeValueList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeValueList");
    }
  }

  final public SqlFieldDefinition SqlFieldDefinition() throws ParseException {
    trace_call("SqlFieldDefinition");
    try {
   SqlType n0;
   NodeOptional n1 = new NodeOptional();
   NodeToken n2;
   Token n3;
   NodeSequence n4;
   SqlFieldContent n5;
   NodeListOptional n6 = new NodeListOptional();
   NodeToken n7;
   Token n8;

   {
   }
      n0 = SqlType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n3 = jj_consume_token(IDENTIFIER);
                        n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
        n4 = new NodeSequence(1);
      n5 = SqlFieldContent();
        n4.addNode(n5);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        n8 = jj_consume_token(STRING);
                    n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      }
     n6.nodes.trimToSize();
     {if (true) return new SqlFieldDefinition(n0,n1,n4,n6);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlFieldDefinition");
    }
  }

  final public SqlFieldContent SqlFieldContent() throws ParseException {
    trace_call("SqlFieldContent");
    try {
   SqlSyntax n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   SqlSyntax n5;

   {
   }
      n0 = SqlSyntax();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_7;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(87);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = SqlSyntax();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new SqlFieldContent(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlFieldContent");
    }
  }

  final public SqlType SqlType() throws ParseException {
    trace_call("SqlType");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX:
        n2 = jj_consume_token(INDEX);
                   n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case CONSTRAINT:
        n4 = jj_consume_token(CONSTRAINT);
                        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new SqlType(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlType");
    }
  }

  final public FieldDefinition FieldDefinition() throws ParseException {
    trace_call("FieldDefinition");
    try {
   NodeOptional n0 = new NodeOptional();
   Label n1;
   TypeDeclaration n2;
   NodeOptional n3 = new NodeOptional();
   TypeArgumentList n4;
   NodeOptional n5 = new NodeOptional();
   NodeToken n6;
   Token n7;
   NodeListOptional n8 = new NodeListOptional();
   ArrayRange n9;
   NodeOptional n10 = new NodeOptional();
   FieldInitializer n11;
   NodeOptional n12 = new NodeOptional();
   FieldCondition n13;
   NodeOptional n14 = new NodeOptional();
   SqlCondition n15;
   NodeOptional n16 = new NodeOptional();
   FieldOptionalClause n17;
   NodeListOptional n18 = new NodeListOptional();
   NodeToken n19;
   Token n20;

   {
   }
      if (jj_2_2(2147483647)) {
        n1 = Label();
        n0.addNode(n1);
      } else {
        ;
      }
      n2 = TypeDeclaration();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 86:
        n4 = TypeArgumentList();
        n3.addNode(n4);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n7 = jj_consume_token(IDENTIFIER);
                        n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 92:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
        }
        n9 = ArrayRange();
        n8.addNode(n9);
      }
     n8.nodes.trimToSize();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 91:
        n11 = FieldInitializer();
        n10.addNode(n11);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 84:
        n13 = FieldCondition();
        n12.addNode(n13);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQL:
        n15 = SqlCondition();
        n14.addNode(n15);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        n17 = FieldOptionalClause();
        n16.addNode(n17);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_9;
        }
        n20 = jj_consume_token(STRING);
                     n19 = JTBToolkit.makeNodeToken(n20);
        n18.addNode(n19);
      }
     n18.nodes.trimToSize();
     {if (true) return new FieldDefinition(n0,n2,n3,n5,n8,n10,n12,n14,n16,n18);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FieldDefinition");
    }
  }

  final public TypeArgumentList TypeArgumentList() throws ParseException {
    trace_call("TypeArgumentList");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   FunctionArgument n4;
   NodeListOptional n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   FunctionArgument n9;
   NodeToken n10;
   Token n11;

   {
   }
      n1 = jj_consume_token(86);
            n0 = JTBToolkit.makeNodeToken(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case FORALL:
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
        n5 = new NodeListOptional();
        n3 = new NodeSequence(2);
        n4 = FunctionArgument();
        n3.addNode(n4);
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 87:
            ;
            break;
          default:
            jj_la1[23] = jj_gen;
            break label_10;
          }
           n6 = new NodeSequence(2);
          n8 = jj_consume_token(87);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n6.addNode(n7);
          n9 = FunctionArgument();
           n6.addNode(n9);
           n5.addNode(n6);
        }
        n5.nodes.trimToSize();
        n3.addNode(n5);
        n2.addNode(n3);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      n11 = jj_consume_token(88);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new TypeArgumentList(n0,n2,n10);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeArgumentList");
    }
  }

  final public FieldInitializer FieldInitializer() throws ParseException {
    trace_call("FieldInitializer");
    try {
   NodeToken n0;
   Token n1;
   TypeValue n2;

   {
   }
      n1 = jj_consume_token(91);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = TypeValue();
     {if (true) return new FieldInitializer(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FieldInitializer");
    }
  }

  final public FieldOptionalClause FieldOptionalClause() throws ParseException {
    trace_call("FieldOptionalClause");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;

   {
   }
      n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
     {if (true) return new FieldOptionalClause(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FieldOptionalClause");
    }
  }

  final public FieldCondition FieldCondition() throws ParseException {
    trace_call("FieldCondition");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;

   {
   }
      n1 = jj_consume_token(84);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
     {if (true) return new FieldCondition(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FieldCondition");
    }
  }

  final public SqlCondition SqlCondition() throws ParseException {
    trace_call("SqlCondition");
    try {
   NodeToken n0;
   Token n1;
   SqlSyntax n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   SqlSyntax n7;

   {
   }
      n1 = jj_consume_token(SQL);
              n0 = JTBToolkit.makeNodeToken(n1);
      n2 = SqlSyntax();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_11;
        }
        n4 = new NodeSequence(2);
        n6 = jj_consume_token(87);
               n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
        n7 = SqlSyntax();
        n4.addNode(n7);
        n3.addNode(n4);
      }
     n3.nodes.trimToSize();
     {if (true) return new SqlCondition(n0,n2,n3);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlCondition");
    }
  }

  final public SqlSyntax SqlSyntax() throws ParseException {
    trace_call("SqlSyntax");
    try {
   NodeToken n0;
   Token n1;

   {
   }
      n1 = jj_consume_token(STRING_LITERAL);
                         n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new SqlSyntax(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlSyntax");
    }
  }

  final public TypeDeclaration TypeDeclaration() throws ParseException {
    trace_call("TypeDeclaration");
    try {
   NodeChoice n0;
   StructDeclaration n1;
   DefinedType n2;
   EnumDeclaration n3;

   {
   }
      if (jj_2_3(2147483647)) {
        n1 = StructDeclaration();
        n0 = new NodeChoice(n1, 0);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIG:
        case BIT:
        case LITTLE:
        case UINT8:
        case UINT16:
        case UINT32:
        case UINT64:
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case STRING:
        case IDENTIFIER:
          n2 = DefinedType();
        n0 = new NodeChoice(n2, 1);
          break;
        case ENUM:
        case BITMASK:
          n3 = EnumDeclaration();
        n0 = new NodeChoice(n3, 2);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new TypeDeclaration(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeDeclaration");
    }
  }

  final public StructDeclaration StructDeclaration() throws ParseException {
    trace_call("StructDeclaration");
    try {
   NodeOptional n0 = new NodeOptional();
   ByteOrderModifier n1;
   NodeOptional n2 = new NodeOptional();
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   NodeOptional n14 = new NodeOptional();
   NodeToken n15;
   Token n16;
   NodeOptional n17 = new NodeOptional();
   NodeSequence n18;
   NodeToken n19;
   Token n20;
   ParameterDefinition n21;
   NodeListOptional n22;
   NodeSequence n23;
   NodeToken n24;
   Token n25;
   ParameterDefinition n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
   DeclarationList n31;
   NodeToken n32;
   Token n33;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIG:
      case LITTLE:
        n1 = ByteOrderModifier();
        n0.addNode(n1);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
      case DATABASE:
      case TABLE:
      case SQLINTEGER:
      case SQLTEXT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNION:
          n5 = jj_consume_token(UNION);
                      n4 = JTBToolkit.makeNodeToken(n5);
           n3 = new NodeChoice(n4, 0);
          break;
        case DATABASE:
          n7 = jj_consume_token(DATABASE);
                         n6 = JTBToolkit.makeNodeToken(n7);
           n3 = new NodeChoice(n6, 1);
          break;
        case TABLE:
          n9 = jj_consume_token(TABLE);
                      n8 = JTBToolkit.makeNodeToken(n9);
           n3 = new NodeChoice(n8, 2);
          break;
        case SQLINTEGER:
          n11 = jj_consume_token(SQLINTEGER);
                            n10 = JTBToolkit.makeNodeToken(n11);
           n3 = new NodeChoice(n10, 3);
          break;
        case SQLTEXT:
          n13 = jj_consume_token(SQLTEXT);
                         n12 = JTBToolkit.makeNodeToken(n13);
           n3 = new NodeChoice(n12, 4);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n16 = jj_consume_token(IDENTIFIER);
                         n15 = JTBToolkit.makeNodeToken(n16);
        n14.addNode(n15);
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 86:
        n22 = new NodeListOptional();
        n18 = new NodeSequence(4);
        n20 = jj_consume_token(86);
                n19 = JTBToolkit.makeNodeToken(n20);
        n18.addNode(n19);
        n21 = ParameterDefinition();
        n18.addNode(n21);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 87:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_12;
          }
           n23 = new NodeSequence(2);
          n25 = jj_consume_token(87);
                   n24 = JTBToolkit.makeNodeToken(n25);
           n23.addNode(n24);
          n26 = ParameterDefinition();
           n23.addNode(n26);
           n22.addNode(n23);
        }
        n22.nodes.trimToSize();
        n18.addNode(n22);
        n28 = jj_consume_token(88);
                n27 = JTBToolkit.makeNodeToken(n28);
        n18.addNode(n27);
        n17.addNode(n18);
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      n30 = jj_consume_token(89);
             n29 = JTBToolkit.makeNodeToken(n30);
      n31 = DeclarationList();
      n33 = jj_consume_token(90);
             n32 = JTBToolkit.makeNodeToken(n33);
     {if (true) return new StructDeclaration(n0,n2,n14,n17,n29,n31,n32);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructDeclaration");
    }
  }

  final public DefinedType DefinedType() throws ParseException {
    trace_call("DefinedType");
    try {
   NodeChoice n0;
   TypeSymbol n1;
   BuiltinType n2;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n1 = TypeSymbol();
        n0 = new NodeChoice(n1, 0);
        break;
      case BIG:
      case BIT:
      case LITTLE:
      case UINT8:
      case UINT16:
      case UINT32:
      case UINT64:
      case INT8:
      case INT16:
      case INT32:
      case INT64:
      case STRING:
        n2 = BuiltinType();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new DefinedType(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DefinedType");
    }
  }

  final public TypeSymbol TypeSymbol() throws ParseException {
    trace_call("TypeSymbol");
    try {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   DotOperand n3;

   {
   }
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 104:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_13;
        }
        n3 = DotOperand();
        n2.addNode(n3);
      }
     n2.nodes.trimToSize();
     {if (true) return new TypeSymbol(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeSymbol");
    }
  }

  final public BuiltinType BuiltinType() throws ParseException {
    trace_call("BuiltinType");
    try {
   NodeOptional n0 = new NodeOptional();
   ByteOrderModifier n1;
   NodeChoice n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   BitField n21;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIG:
      case LITTLE:
        n1 = ByteOrderModifier();
        n0.addNode(n1);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UINT8:
        n4 = jj_consume_token(UINT8);
                      n3 = JTBToolkit.makeNodeToken(n4);
           n2 = new NodeChoice(n3, 0);
        break;
      case UINT16:
        n6 = jj_consume_token(UINT16);
                       n5 = JTBToolkit.makeNodeToken(n6);
           n2 = new NodeChoice(n5, 1);
        break;
      case UINT32:
        n8 = jj_consume_token(UINT32);
                       n7 = JTBToolkit.makeNodeToken(n8);
           n2 = new NodeChoice(n7, 2);
        break;
      case UINT64:
        n10 = jj_consume_token(UINT64);
                        n9 = JTBToolkit.makeNodeToken(n10);
           n2 = new NodeChoice(n9, 3);
        break;
      case INT8:
        n12 = jj_consume_token(INT8);
                      n11 = JTBToolkit.makeNodeToken(n12);
           n2 = new NodeChoice(n11, 4);
        break;
      case INT16:
        n14 = jj_consume_token(INT16);
                       n13 = JTBToolkit.makeNodeToken(n14);
           n2 = new NodeChoice(n13, 5);
        break;
      case INT32:
        n16 = jj_consume_token(INT32);
                       n15 = JTBToolkit.makeNodeToken(n16);
           n2 = new NodeChoice(n15, 6);
        break;
      case INT64:
        n18 = jj_consume_token(INT64);
                       n17 = JTBToolkit.makeNodeToken(n18);
           n2 = new NodeChoice(n17, 7);
        break;
      case STRING:
        n20 = jj_consume_token(STRING);
                        n19 = JTBToolkit.makeNodeToken(n20);
           n2 = new NodeChoice(n19, 8);
        break;
      case BIT:
        n21 = BitField();
           n2 = new NodeChoice(n21, 9);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new BuiltinType(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BuiltinType");
    }
  }

  final public BitField BitField() throws ParseException {
    trace_call("BitField");
    try {
   NodeToken n0;
   Token n1;
   NodeChoice n2;
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   ShiftExpression n11;
   NodeToken n12;
   Token n13;

   {
   }
      n1 = jj_consume_token(BIT);
              n0 = JTBToolkit.makeNodeToken(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 84:
           n3 = new NodeSequence(2);
        n5 = jj_consume_token(84);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        n7 = jj_consume_token(INTEGER_LITERAL);
                                n6 = JTBToolkit.makeNodeToken(n7);
           n3.addNode(n6);
           n2 = new NodeChoice(n3, 0);
        break;
      case LT:
           n8 = new NodeSequence(3);
        n10 = jj_consume_token(LT);
                    n9 = JTBToolkit.makeNodeToken(n10);
           n8.addNode(n9);
        n11 = ShiftExpression();
           n8.addNode(n11);
        n13 = jj_consume_token(GT);
                    n12 = JTBToolkit.makeNodeToken(n13);
           n8.addNode(n12);
           n2 = new NodeChoice(n8, 1);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new BitField(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BitField");
    }
  }

  final public ByteOrderModifier ByteOrderModifier() throws ParseException {
    trace_call("ByteOrderModifier");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIG:
        n2 = jj_consume_token(BIG);
                 n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case LITTLE:
        n4 = jj_consume_token(LITTLE);
                    n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new ByteOrderModifier(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ByteOrderModifier");
    }
  }

  final public ArrayRange ArrayRange() throws ParseException {
    trace_call("ArrayRange");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   RangeExpression n3;
   NodeToken n4;
   Token n5;

   {
   }
      n1 = jj_consume_token(92);
            n0 = JTBToolkit.makeNodeToken(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case FORALL:
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
        n3 = RangeExpression();
        n2.addNode(n3);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      n5 = jj_consume_token(93);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ArrayRange(n0,n2,n4);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ArrayRange");
    }
  }

  final public Expression Expression() throws ParseException {
    trace_call("Expression");
    try {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   CommaOperand n2;

   {
   }
      n0 = AssignmentExpression();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_14;
        }
        n2 = CommaOperand();
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new Expression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression");
    }
  }

  final public CommaOperand CommaOperand() throws ParseException {
    trace_call("CommaOperand");
    try {
   NodeToken n0;
   Token n1;
   AssignmentExpression n2;

   {
   }
      n1 = jj_consume_token(87);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = AssignmentExpression();
     {if (true) return new CommaOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CommaOperand");
    }
  }

  final public AssignmentExpression AssignmentExpression() throws ParseException {
    trace_call("AssignmentExpression");
    try {
   NodeChoice n0;
   NodeSequence n1;
   UnaryExpression n2;
   AssignmentOperator n3;
   AssignmentExpression n4;
   QuantifiedExpression n5;

   {
   }
      if (jj_2_4(2147483647)) {
        n1 = new NodeSequence(4);
        n2 = UnaryExpression();
        n1.addNode(n2);
        n3 = AssignmentOperator();
        n1.addNode(n3);
        n4 = AssignmentExpression();
        n1.addNode(n4);
        n0 = new NodeChoice(n1, 0);
      } else if (jj_2_5(3)) {
        n5 = QuantifiedExpression();
        n0 = new NodeChoice(n5, 1);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new AssignmentExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AssignmentExpression");
    }
  }

  final public AssignmentOperator AssignmentOperator() throws ParseException {
    trace_call("AssignmentOperator");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 91:
        n2 = jj_consume_token(91);
                  n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case 94:
        n4 = jj_consume_token(94);
                   n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case 95:
        n6 = jj_consume_token(95);
                   n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case 96:
        n8 = jj_consume_token(96);
                   n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      case 97:
        n10 = jj_consume_token(97);
                    n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
        break;
      case 98:
        n12 = jj_consume_token(98);
                    n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
        break;
      case 99:
        n14 = jj_consume_token(99);
                     n13 = JTBToolkit.makeNodeToken(n14);
           n0 = new NodeChoice(n13, 6);
        break;
      case 100:
        n16 = jj_consume_token(100);
                     n15 = JTBToolkit.makeNodeToken(n16);
           n0 = new NodeChoice(n15, 7);
        break;
      case 101:
        n18 = jj_consume_token(101);
                    n17 = JTBToolkit.makeNodeToken(n18);
           n0 = new NodeChoice(n17, 8);
        break;
      case 102:
        n20 = jj_consume_token(102);
                    n19 = JTBToolkit.makeNodeToken(n20);
           n0 = new NodeChoice(n19, 9);
        break;
      case 103:
        n22 = jj_consume_token(103);
                    n21 = JTBToolkit.makeNodeToken(n22);
           n0 = new NodeChoice(n21, 10);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AssignmentOperator");
    }
  }

  final public QuantifiedExpression QuantifiedExpression() throws ParseException {
    trace_call("QuantifiedExpression");
    try {
   NodeOptional n0 = new NodeOptional();
   Quantifier n1;
   ConditionalExpression n2;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FORALL:
        n1 = Quantifier();
        n0.addNode(n1);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      n2 = ConditionalExpression();
     {if (true) return new QuantifiedExpression(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("QuantifiedExpression");
    }
  }

  final public Quantifier Quantifier() throws ParseException {
    trace_call("Quantifier");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   UnaryExpression n6;
   NodeToken n7;
   Token n8;

   {
   }
      n1 = jj_consume_token(FORALL);
                 n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
      n5 = jj_consume_token(IN);
             n4 = JTBToolkit.makeNodeToken(n5);
      n6 = UnaryExpression();
      n8 = jj_consume_token(84);
            n7 = JTBToolkit.makeNodeToken(n8);
     {if (true) return new Quantifier(n0,n2,n4,n6,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Quantifier");
    }
  }

  final public ConditionalExpression ConditionalExpression() throws ParseException {
    trace_call("ConditionalExpression");
    try {
   LogicalOrExpression n0;
   NodeOptional n1 = new NodeOptional();
   ConditionalExpressionOperand n2;

   {
   }
      n0 = LogicalOrExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTIONMARK:
        n2 = ConditionalExpressionOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
     {if (true) return new ConditionalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalExpression");
    }
  }

  final public ConditionalExpressionOperand ConditionalExpressionOperand() throws ParseException {
    trace_call("ConditionalExpressionOperand");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
   ConditionalExpression n5;

   {
   }
      n1 = jj_consume_token(QUESTIONMARK);
                       n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
      n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
      n5 = ConditionalExpression();
     {if (true) return new ConditionalExpressionOperand(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalExpressionOperand");
    }
  }

  final public ConstantExpression ConstantExpression() throws ParseException {
    trace_call("ConstantExpression");
    try {
   ConditionalExpression n0;

   {
   }
      n0 = ConditionalExpression();
     {if (true) return new ConstantExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConstantExpression");
    }
  }

  final public RangeExpression RangeExpression() throws ParseException {
    trace_call("RangeExpression");
    try {
   Expression n0;
   NodeOptional n1 = new NodeOptional();
   UpperBoundExpression n2;

   {
   }
      n0 = Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RANGE:
        n2 = UpperBoundExpression();
        n1.addNode(n2);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
     {if (true) return new RangeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RangeExpression");
    }
  }

  final public UpperBoundExpression UpperBoundExpression() throws ParseException {
    trace_call("UpperBoundExpression");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;

   {
   }
      n1 = jj_consume_token(RANGE);
                n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
     {if (true) return new UpperBoundExpression(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UpperBoundExpression");
    }
  }

  final public LogicalOrExpression LogicalOrExpression() throws ParseException {
    trace_call("LogicalOrExpression");
    try {
   LogicalAndExpression n0;
   NodeOptional n1 = new NodeOptional();
   LogicalOrOperand n2;

   {
   }
      n0 = LogicalAndExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICALOR:
        n2 = LogicalOrOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
     {if (true) return new LogicalOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalOrExpression");
    }
  }

  final public LogicalOrOperand LogicalOrOperand() throws ParseException {
    trace_call("LogicalOrOperand");
    try {
   NodeToken n0;
   Token n1;
   LogicalOrExpression n2;

   {
   }
      n1 = jj_consume_token(LOGICALOR);
                    n0 = JTBToolkit.makeNodeToken(n1);
      n2 = LogicalOrExpression();
     {if (true) return new LogicalOrOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalOrOperand");
    }
  }

  final public LogicalAndExpression LogicalAndExpression() throws ParseException {
    trace_call("LogicalAndExpression");
    try {
   InclusiveOrExpression n0;
   NodeOptional n1 = new NodeOptional();
   LogicalAndOperand n2;

   {
   }
      n0 = InclusiveOrExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICALAND:
        n2 = LogicalAndOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
     {if (true) return new LogicalAndExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalAndExpression");
    }
  }

  final public LogicalAndOperand LogicalAndOperand() throws ParseException {
    trace_call("LogicalAndOperand");
    try {
   NodeToken n0;
   Token n1;
   LogicalAndExpression n2;

   {
   }
      n1 = jj_consume_token(LOGICALAND);
                     n0 = JTBToolkit.makeNodeToken(n1);
      n2 = LogicalAndExpression();
     {if (true) return new LogicalAndOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalAndOperand");
    }
  }

  final public InclusiveOrExpression InclusiveOrExpression() throws ParseException {
    trace_call("InclusiveOrExpression");
    try {
   ExclusiveOrExpression n0;
   NodeOptional n1 = new NodeOptional();
   InclusiveOrOperand n2;

   {
   }
      n0 = ExclusiveOrExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        n2 = InclusiveOrOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
     {if (true) return new InclusiveOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InclusiveOrExpression");
    }
  }

  final public InclusiveOrOperand InclusiveOrOperand() throws ParseException {
    trace_call("InclusiveOrOperand");
    try {
   NodeToken n0;
   Token n1;
   InclusiveOrExpression n2;

   {
   }
      n1 = jj_consume_token(OR);
             n0 = JTBToolkit.makeNodeToken(n1);
      n2 = InclusiveOrExpression();
     {if (true) return new InclusiveOrOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InclusiveOrOperand");
    }
  }

  final public ExclusiveOrExpression ExclusiveOrExpression() throws ParseException {
    trace_call("ExclusiveOrExpression");
    try {
   AndExpression n0;
   NodeOptional n1 = new NodeOptional();
   ExclusiveOrOperand n2;

   {
   }
      n0 = AndExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        n2 = ExclusiveOrOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
     {if (true) return new ExclusiveOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExclusiveOrExpression");
    }
  }

  final public ExclusiveOrOperand ExclusiveOrOperand() throws ParseException {
    trace_call("ExclusiveOrOperand");
    try {
   NodeToken n0;
   Token n1;
   ExclusiveOrExpression n2;

   {
   }
      n1 = jj_consume_token(XOR);
              n0 = JTBToolkit.makeNodeToken(n1);
      n2 = ExclusiveOrExpression();
     {if (true) return new ExclusiveOrOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExclusiveOrOperand");
    }
  }

  final public AndExpression AndExpression() throws ParseException {
    trace_call("AndExpression");
    try {
   EqualityExpression n0;
   NodeOptional n1 = new NodeOptional();
   AndOperand n2;

   {
   }
      n0 = EqualityExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        n2 = AndOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
     {if (true) return new AndExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AndExpression");
    }
  }

  final public AndOperand AndOperand() throws ParseException {
    trace_call("AndOperand");
    try {
   NodeToken n0;
   Token n1;
   AndExpression n2;

   {
   }
      n1 = jj_consume_token(AND);
              n0 = JTBToolkit.makeNodeToken(n1);
      n2 = AndExpression();
     {if (true) return new AndOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AndOperand");
    }
  }

  final public EqualityExpression EqualityExpression() throws ParseException {
    trace_call("EqualityExpression");
    try {
   RelationalExpression n0;
   NodeOptional n1 = new NodeOptional();
   EqualityOperand n2;

   {
   }
      n0 = RelationalExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        n2 = EqualityOperand();
        n1.addNode(n2);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
     {if (true) return new EqualityExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EqualityExpression");
    }
  }

  final public EqualityOperand EqualityOperand() throws ParseException {
    trace_call("EqualityOperand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   EqualityExpression n5;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        n2 = jj_consume_token(EQ);
                   n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case NE:
        n4 = jj_consume_token(NE);
                   n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n5 = EqualityExpression();
     {if (true) return new EqualityOperand(n0,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EqualityOperand");
    }
  }

  final public RelationalExpression RelationalExpression() throws ParseException {
    trace_call("RelationalExpression");
    try {
   ShiftExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   RelationalOperand n2;

   {
   }
      n0 = ShiftExpression();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LE:
        case LT:
        case GE:
        case GT:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_15;
        }
        n2 = RelationalOperand();
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new RelationalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelationalExpression");
    }
  }

  final public RelationalOperand RelationalOperand() throws ParseException {
    trace_call("RelationalOperand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   ShiftExpression n9;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        n2 = jj_consume_token(LT);
                   n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case LE:
        n4 = jj_consume_token(LE);
                   n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case GT:
        n6 = jj_consume_token(GT);
                   n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case GE:
        n8 = jj_consume_token(GE);
                   n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n9 = ShiftExpression();
     {if (true) return new RelationalOperand(n0,n9);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelationalOperand");
    }
  }

  final public ShiftExpression ShiftExpression() throws ParseException {
    trace_call("ShiftExpression");
    try {
   AdditiveExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   ShiftOperand n2;

   {
   }
      n0 = AdditiveExpression();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHIFTLEFT:
        case SHIFTRIGHT:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_16;
        }
        n2 = ShiftOperand();
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new ShiftExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ShiftExpression");
    }
  }

  final public ShiftOperand ShiftOperand() throws ParseException {
    trace_call("ShiftOperand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   AdditiveExpression n5;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHIFTLEFT:
        n2 = jj_consume_token(SHIFTLEFT);
                          n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case SHIFTRIGHT:
        n4 = jj_consume_token(SHIFTRIGHT);
                           n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n5 = AdditiveExpression();
     {if (true) return new ShiftOperand(n0,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ShiftOperand");
    }
  }

  final public AdditiveExpression AdditiveExpression() throws ParseException {
    trace_call("AdditiveExpression");
    try {
   MultiplicativeExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   Summand n2;

   {
   }
      n0 = MultiplicativeExpression();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_17;
        }
        n2 = Summand();
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new AdditiveExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AdditiveExpression");
    }
  }

  final public Summand Summand() throws ParseException {
    trace_call("Summand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   MultiplicativeExpression n5;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        n2 = jj_consume_token(PLUS);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case MINUS:
        n4 = jj_consume_token(MINUS);
                      n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n5 = MultiplicativeExpression();
     {if (true) return new Summand(n0,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Summand");
    }
  }

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
    trace_call("MultiplicativeExpression");
    try {
   CastExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   Multiplicand n2;

   {
   }
      n0 = CastExpression();
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case DIVIDE:
        case MODULO:
          ;
          break;
        default:
          jj_la1[58] = jj_gen;
          break label_18;
        }
        n2 = Multiplicand();
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new MultiplicativeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MultiplicativeExpression");
    }
  }

  final public Multiplicand Multiplicand() throws ParseException {
    trace_call("Multiplicand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   CastExpression n7;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        n2 = jj_consume_token(MULTIPLY);
                         n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case DIVIDE:
        n4 = jj_consume_token(DIVIDE);
                       n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case MODULO:
        n6 = jj_consume_token(MODULO);
                       n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n7 = CastExpression();
     {if (true) return new Multiplicand(n0,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Multiplicand");
    }
  }

  final public CastExpression CastExpression() throws ParseException {
    trace_call("CastExpression");
    try {
   NodeChoice n0;
   CastOperand n1;
   UnaryExpression n2;

   {
   }
      if (jj_2_6(2147483647)) {
        n1 = CastOperand();
        n0 = new NodeChoice(n1, 0);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case PLUS:
        case MINUS:
        case TILDE:
        case BANG:
        case FLOATING_POINT_LITERAL:
        case INTEGER_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case 86:
          n2 = UnaryExpression();
        n0 = new NodeChoice(n2, 1);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CastExpression");
    }
  }

  final public CastOperand CastOperand() throws ParseException {
    trace_call("CastOperand");
    try {
   NodeToken n0;
   Token n1;
   DefinedType n2;
   NodeToken n3;
   Token n4;
   CastExpression n5;

   {
   }
      n1 = jj_consume_token(86);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = DefinedType();
      n4 = jj_consume_token(88);
            n3 = JTBToolkit.makeNodeToken(n4);
      n5 = CastExpression();
     {if (true) return new CastOperand(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CastOperand");
    }
  }

  final public UnaryExpression UnaryExpression() throws ParseException {
    trace_call("UnaryExpression");
    try {
   NodeChoice n0;
   PostfixExpression n1;
   UnaryOperand n2;
   SizeOfOperand n3;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
        n1 = PostfixExpression();
        n0 = new NodeChoice(n1, 0);
        break;
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
        n2 = UnaryOperand();
        n0 = new NodeChoice(n2, 1);
        break;
      case SIZEOF:
        n3 = SizeOfOperand();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryExpression");
    }
  }

  final public UnaryOperand UnaryOperand() throws ParseException {
    trace_call("UnaryOperand");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   CastExpression n9;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        n2 = jj_consume_token(PLUS);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case MINUS:
        n4 = jj_consume_token(MINUS);
                      n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case TILDE:
        n6 = jj_consume_token(TILDE);
                      n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case BANG:
        n8 = jj_consume_token(BANG);
                     n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n9 = CastExpression();
     {if (true) return new UnaryOperand(n0,n9);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryOperand");
    }
  }

  final public SizeOfOperand SizeOfOperand() throws ParseException {
    trace_call("SizeOfOperand");
    try {
   NodeToken n0;
   Token n1;
   UnaryExpression n2;

   {
   }
      n1 = jj_consume_token(SIZEOF);
                 n0 = JTBToolkit.makeNodeToken(n1);
      n2 = UnaryExpression();
     {if (true) return new SizeOfOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SizeOfOperand");
    }
  }

  final public PostfixExpression PostfixExpression() throws ParseException {
    trace_call("PostfixExpression");
    try {
   PrimaryExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeChoice n2;
   ArrayOperand n3;
   FunctionArgumentList n4;
   DotOperand n5;
   ChoiceOperand n6;

   {
   }
      n0 = PrimaryExpression();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IS:
        case 86:
        case 92:
        case 104:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_19;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 92:
          n3 = ArrayOperand();
           n2 = new NodeChoice(n3, 0);
          break;
        case 86:
          n4 = FunctionArgumentList();
           n2 = new NodeChoice(n4, 1);
          break;
        case 104:
          n5 = DotOperand();
           n2 = new NodeChoice(n5, 2);
          break;
        case IS:
          n6 = ChoiceOperand();
           n2 = new NodeChoice(n6, 3);
          break;
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new PostfixExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PostfixExpression");
    }
  }

  final public ChoiceOperand ChoiceOperand() throws ParseException {
    trace_call("ChoiceOperand");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;

   {
   }
      n1 = jj_consume_token(IS);
             n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ChoiceOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ChoiceOperand");
    }
  }

  final public ArrayOperand ArrayOperand() throws ParseException {
    trace_call("ArrayOperand");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;

   {
   }
      n1 = jj_consume_token(92);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
      n4 = jj_consume_token(93);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new ArrayOperand(n0,n2,n3);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ArrayOperand");
    }
  }

  final public FunctionArgumentList FunctionArgumentList() throws ParseException {
    trace_call("FunctionArgumentList");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   FunctionArgument n4;
   NodeListOptional n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   FunctionArgument n9;
   NodeToken n10;
   Token n11;

   {
   }
      n1 = jj_consume_token(86);
            n0 = JTBToolkit.makeNodeToken(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case FORALL:
      case PLUS:
      case MINUS:
      case TILDE:
      case BANG:
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case 86:
        n5 = new NodeListOptional();
        n3 = new NodeSequence(2);
        n4 = FunctionArgument();
        n3.addNode(n4);
        label_20:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 87:
            ;
            break;
          default:
            jj_la1[65] = jj_gen;
            break label_20;
          }
           n6 = new NodeSequence(2);
          n8 = jj_consume_token(87);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n6.addNode(n7);
          n9 = FunctionArgument();
           n6.addNode(n9);
           n5.addNode(n6);
        }
        n5.nodes.trimToSize();
        n3.addNode(n5);
        n2.addNode(n3);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      n11 = jj_consume_token(88);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new FunctionArgumentList(n0,n2,n10);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionArgumentList");
    }
  }

  final public DotOperand DotOperand() throws ParseException {
    trace_call("DotOperand");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;

   {
   }
      n1 = jj_consume_token(104);
            n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new DotOperand(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DotOperand");
    }
  }

  final public PrimaryExpression PrimaryExpression() throws ParseException {
    trace_call("PrimaryExpression");
    try {
   NodeChoice n0;
   VariableName n1;
   Constant n2;
   ParenthesizedExpression n3;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n1 = VariableName();
        n0 = new NodeChoice(n1, 0);
        break;
      case FLOATING_POINT_LITERAL:
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        n2 = Constant();
        n0 = new NodeChoice(n2, 1);
        break;
      case 86:
        n3 = ParenthesizedExpression();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new PrimaryExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrimaryExpression");
    }
  }

  final public ParenthesizedExpression ParenthesizedExpression() throws ParseException {
    trace_call("ParenthesizedExpression");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;

   {
   }
      n1 = jj_consume_token(86);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
      n4 = jj_consume_token(88);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new ParenthesizedExpression(n0,n2,n3);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedExpression");
    }
  }

  final public VariableName VariableName() throws ParseException {
    trace_call("VariableName");
    try {
   NodeToken n0;
   Token n1;

   {
   }
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new VariableName(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("VariableName");
    }
  }

  final public FunctionArgument FunctionArgument() throws ParseException {
    trace_call("FunctionArgument");
    try {
   AssignmentExpression n0;

   {
   }
      n0 = AssignmentExpression();
     {if (true) return new FunctionArgument(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionArgument");
    }
  }

  final public Constant Constant() throws ParseException {
    trace_call("Constant");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;

   {
   }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        n2 = jj_consume_token(INTEGER_LITERAL);
                             n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case FLOATING_POINT_LITERAL:
        n4 = jj_consume_token(FLOATING_POINT_LITERAL);
                                    n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
        break;
      case CHARACTER_LITERAL:
        n6 = jj_consume_token(CHARACTER_LITERAL);
                               n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
        break;
      case STRING_LITERAL:
        n8 = jj_consume_token(STRING_LITERAL);
                            n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new Constant(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Constant");
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_3R_78() {
    if (jj_3R_92()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(MODULO)) return true;
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(BIT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) return true;
    }
    return false;
  }

  final private boolean jj_3R_221() {
    if (jj_scan_token(DIVIDE)) return true;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_scan_token(MULTIPLY)) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_3R_33()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_201()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(LOGICALOR)) return true;
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    }
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(CONDITION)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(86)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_181()) jj_scanpos = xsp;
    if (jj_scan_token(88)) return true;
    if (jj_scan_token(89)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_182()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(90)) return true;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_3R_200()) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_3R_199()) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_3R_198()) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_3R_127()) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_94()) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_3R_197()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(INT64)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_78()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_3R_213()) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_3R_196()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(INT32)) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(INT16)) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_3R_51()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_191()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(INT8)) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_195()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(UINT64)) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(UINT32)) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_scan_token(RANGE)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(UINT16)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    xsp = jj_scanpos;
    if (jj_3R_173()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_175()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_176()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_180()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(UINT8)) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_30()) return true;
    if (jj_scan_token(85)) return true;
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_3R_227()) return true;
    return false;
  }

  final private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) return true;
    }
    if (jj_3R_169()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_96()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    if (jj_scan_token(84)) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_192()) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(CONSTRAINT)) return true;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(INDEX)) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_3R_169()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_170()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(86)) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(88)) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_166()) return true;
    if (jj_scan_token(83)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(QUESTIONMARK)) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(84)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_scan_token(SHIFTRIGHT)) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_3R_165()) return true;
    if (jj_scan_token(83)) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_95()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_scan_token(SHIFTLEFT)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_164()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_3R_163()) return true;
    if (jj_scan_token(83)) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_207()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) return true;
    }
    if (jj_3R_161()) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_207()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_208()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_82()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(86)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_3R_171()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(104)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_3R_161()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_162()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(FORALL)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IN)) return true;
    if (jj_3R_26()) return true;
    if (jj_scan_token(84)) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_134()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_184()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) jj_scanpos = xsp;
    if (jj_3R_186()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_187()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_148()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(86)) return true;
    if (jj_3R_33()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_133()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(88)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_3R_148()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_149()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) return true;
    }
    }
    }
    if (jj_3R_153()) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(SQLTEXT)) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(86)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) jj_scanpos = xsp;
    if (jj_scan_token(88)) return true;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(SQLINTEGER)) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(TABLE)) return true;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_scan_token(DATABASE)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(103)) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_183()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_225()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(102)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(101)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(100)) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_3R_188()) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(99)) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(90)) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(92)) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(93)) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(98)) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_167()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(97)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(96)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(95)) return true;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_scan_token(89)) return true;
    if (jj_3R_219()) return true;
    if (jj_scan_token(90)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(94)) return true;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(91)) return true;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  final private boolean jj_3R_183() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    }
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) return true;
    }
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_123()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    }
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(CONST)) return true;
    if (jj_3R_56()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(91)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_3R_168()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_3R_158()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_72()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_26()) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(91)) return true;
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_26()) return true;
    if (jj_3R_27()) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_135()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(SIZEOF)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3_5()) return true;
    }
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_160()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_3R_150()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_207()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_scan_token(SQL)) return true;
    if (jj_3R_207()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_218()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    }
    }
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(BITMASK)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(ENUM)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_52()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_53()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_3R_152()) return true;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_scan_token(84)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    }
    if (jj_3R_82()) return true;
    xsp = jj_scanpos;
    if (jj_3R_114()) jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    if (jj_3R_115()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_116()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(90)) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_3R_141()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_3R_224()) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(92)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_217()) jj_scanpos = xsp;
    if (jj_scan_token(93)) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(91)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(LITTLE)) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(BIG)) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(86)) return true;
    if (jj_3R_50()) return true;
    if (jj_scan_token(88)) return true;
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_124()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_56()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_scan_token(87)) return true;
    if (jj_3R_148()) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(LOGICALAND)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_3R_148()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_223()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_153()) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(86)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    if (jj_scan_token(88)) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_3R_202()) return true;
    if (jj_scan_token(83)) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(84)) return true;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_126()) return true;
    return false;
  }

  public DSTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[69];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xb57e0000,0xb57e0000,0x0,0xb57c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb57c0000,0x140000,0x0,0x0,0x0,0x0,0x0,0xb57c0000,0x0,0x140000,0xb5680000,0x0,0x140000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1fe0ffa,0x1fe0ffa,0x0,0x407da,0x1e20800,0x18,0x0,0x0,0x0,0x1e00800,0x0,0x0,0x40000,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x8000,0x4000,0x40000,0x0,0x1e20800,0x0,0x4001a,0x0,0x7c0,0x7c0,0x0,0x0,0x0,0x40002,0x0,0x0,0x40002,0x10000000,0x0,0x1e20800,0x0,0x0,0x20000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x78000000,0x78000000,0x6000000,0x6000000,0x600000,0x600000,0x0,0x0,0x1e00800,0x1e00800,0x1e00000,0x2000,0x2000,0x0,0x1e20800,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x241e800,0x241e800,0x800000,0x2410000,0x41e800,0x0,0x10000,0x800000,0x8000000,0x241e800,0x800000,0x10000,0x0,0x800000,0x0,0x400000,0x10000,0x10000000,0x8000000,0x100000,0x0,0x0,0x0,0x800000,0x41e800,0x800000,0x10000,0x0,0x0,0x0,0x10000,0x800000,0x400000,0x10000,0x0,0x0,0x0,0x100000,0x0,0x41e800,0x800000,0xc8000000,0x0,0x200,0x0,0x80,0x100,0x40,0x10,0x20,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0xe,0x41e800,0x41e800,0x0,0x10400000,0x10400000,0x800000,0x41e800,0x41e800,0xe800,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public DS(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public DS(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public DS(DSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(DSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 69; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[105];
    for (int i = 0; i < 105; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 69; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 105; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

  final public void enable_tracing() {
    trace_enabled = true;
  }

  final public void disable_tracing() {
    trace_enabled = false;
  }

  final private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  final private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  final private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(">" + where);
    }
  }

  final private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      NodeToken node = new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);

      if ( t.specialToken == null )
         return node;

      Vector temp = new Vector();
      Token orig = t;

      while ( t.specialToken != null ) {
         t = t.specialToken;
         temp.addElement(new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn));
      }

      // Reverse the special token list
      for ( int i = temp.size() - 1; i >= 0; --i )
         node.addSpecial((NodeToken)temp.elementAt(i));

      node.trimSpecials();
      return node;
   }
}
