package datascript.metamodel;

Model
{
    int32        numTypes;
    Type         types[numTypes];
    
    int32        numFields;
    Field        fields[numFields];
    
    int32        numExpr;
    Expression   expressions[numExpr];
    
    int32        numPackages;
    Package      packages[numPackages];
    
    int32        numNames;
    string       names[numNames];
};

subtype int32 NameId;

Package
{
    int32    packageId;
    NameId   packageName;
    int32    numImports;
    Import   imports[numImports];
    int32    numTypes;
    TypeId   types[numTypes];
};

Import
{
    int8 dummy;
};

subtype int32 TypeId;

Type
{
    TypeId   typeId;
    NameId   typeName;
    Category category;
    int32    size;
    TypeInfo(category) info;
};

enum int8 Category
{
    BUILTIN,
    BITFIELD,
    ENUM,
    SUBTYPE,
    SEQUENCE,
    UNION,
    ARRAY 
};

const int8 useExpression = 0;

union TypeInfo (Category category)
{
    BuiltInInfo        builtInInfo      : category == Category.BUILTIN;
    BitfieldInfo       bitfieldInfo     : category == Category.BITFIELD;
    EnumInfo           enumInfo         : category == Category.ENUM;
    //SubtypeInfo      subtypeInfo      : category == Category.SUBTYPE;
    SequenceInfo       sequenceInfo     : category == Category.SEQUENCE;
    UnionInfo          unionInfo        : category == Category.UNION;
    ArrayInfo          arrayInfo        : category == Category.ARRAY;
};


enum int8 BuiltInInfo
{
    INT8,
    INT16,
    INT32,
    INT64,
    UINT8,
    UINT16,
    UINT32,
    UINT64,
    STRING
};


subtype int32 FieldId;
subtype int32 TypeRef;


BitfieldInfo
{
    uint32        numBits;   // see DataScript Language Overview 3.2 (The length is not limited)
    ExpressionId  exprId    if useExpression == numBits;
};


EnumInfo
{
    // The bits length of the enum element
    int8 bits;

    // Lits of constants
    uint32     numConsts;
    bit<bits>  consts[numConsts];
};


CompoundInfo
{
    // Parameters list
    int8       numParams;
    ParamInfo  params[numParams];

    // Fields list
    int16      numFields;
    FieldId    fields[numFields];
};


ParamInfo
{
    TypeRef type;
    NameId  nameId;     // !!! Probably, it is not necessary to store name of parameters 
};


subtype CompoundInfo SequenceInfo;
subtype CompoundInfo UnionInfo;


ArrayInfo
{
    TypeRef       elementType;  // reference to the type of the array element
    ExpressionId  lengthExpr;   // defines array length calculation expression 
};


Field
{
    int16    pos;
    NameId   name;
    TypeRef  type;
    bit:1    isOptional;
    bit:1    hasConstraint;
    bit:1    hasAlignment;
    bit:1    hasLabel;
    bit:1        hasArguments;

align(8):
    ExpressionId  optional   if 0 != isOptional;
    ExpressionId  constraint if 0 != hasConstraint;
    int32         alignment  if 0 != hasAlignment;
    ExpressionId  label      if 0 != hasLabel;
    ExpressionId  arguments  if 0 != hasArguments;      
};


subtype int32 ExpressionId;


//Expression
//{
//    TypeId  type;
//    bit:1   isConstant;
//    bit:7   arity;
//    ExpressionInfo info;
//    Value   value if isConstant;
//};


Expression
{
    Arity arity;
    ExpressionInfo(arity) info;
};


enum uint8 Arity
{
        ATOM,
        UNARY,
        BINARY,
        TERNARY
};

                    
union ExpressionInfo (Arity arity)
{
    Atom    atom    : arity == Arity.ATOM;
    Unary   unary   : arity == Arity.UNARY;
    Binary  binary  : arity == Arity.BINARY;
    Ternary ternary : arity == Arity.TERNARY;
};


Atom
{
        AtomType type;
    AtomInfo(type) info;
};


Unary
{
    UnaryOperator op;
    ExpressionId  arg1;
};


Binary
{
    BinaryOperator op;
    ExpressionId  arg1;
    ExpressionId  arg2;
};


Ternary
{
    TernaryOperator op;
    ExpressionId    arg1;
    ExpressionId    arg2;
    ExpressionId    arg3;
};

enum int8 AtomType
{
    CONST,                              // define explicit and implicit constants (integer literal, enumeration and e.t.) 
    LOCAL_FIELD_REF,    // Reference to the field of the current compound type
    GLOBAL_FIELD_REF,   // Reference to the global field
    PARAM_REF                   // Reference to the parameter
};


union AtomInfo(AtomType type)
{
        Value          value     : type == AtomType.CONST;
        LocalFieldRef  lfieldRef : type == AtomType.LOCAL_FIELD_REF;
        GlobalFieldRef gfieldRef : type == AtomType.GLOBAL_FIELD_REF;
        ParamRef       paramRef  : type == AtomType.PARAM_REF;
        
        // Probably, the definition has not completed yet. 
};


subtype int64 Value;


enum int8 UnaryOperator 
{
        UPLUS,
        UMINUS,
        TILDE,
        BANG,
        LPAREN,
        INDEX,
        LENGTHOF,
        SIZEOF,
        BITSIZEOF,
        SUM,
        FUNCTIONCALL
};

enum int8 BinaryOperator
{
        COMMA,
        LOGICALOR,
        LOGICALAND,
        OR,
        XOR,
        AND,
        EQ,
        NE,
        LT,
        LE,
        GE,
        GT,
        LSHIFT,
        RSHIFT,
        PLUS,
        MINUS,
        MULTIPLY,
        DIVIDE,
        MODULO,
        ARRAYELEM,
        DOT
};
  
enum int8 TernaryOperator
{
        QUESTIONMARK
};


LocalFieldRef
{
        int16   fieldIndex;             // field index in the current compound type 
};


GlobalFieldRef
{
        TypeRef type;                   // Reference to the compound type
        int16   fieldIndex;             // field index in the compound type 
};


ParamRef
{
        int8    paramIndex;             // index  in the parameters list of the current compound type
        int16   fieldIndex;             // field index in the compound type 
};

