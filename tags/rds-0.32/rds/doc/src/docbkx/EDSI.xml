<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<article>
  <title>Developing an Event-Based DataScript Instance Parser</title>

  <articleinfo>
    <author>
      <firstname>Harald</firstname>

      <surname>Wellmann</surname>

      <email>HWellmann@harmanbecker.com</email>
    </author>

    <affiliation>
      <orgname>Harman/Becker Automotive Systems</orgname>
    </affiliation>

    <revhistory>
      <revision>
        <revnumber>0.1</revnumber>

        <date>16 Nov 2007</date>

        <revdescription>
          <para>Initial version.</para>
        </revdescription>
      </revision>
    </revhistory>
  </articleinfo>

  <section>
    <title>Introduction</title>

    <section>
      <title>Motivation</title>

      <para>DataScript is a formal language for modelling binary datatypes,
      bitstreams or file formats. <emphasis>rds</emphasis> (short for
      Relational DataScript) is a DataScript parser and code generator
      implementation. Using the code generated by <emphasis>rds</emphasis>,
      one can encode and decode bitstreams compliant to a given format
      specification.</para>

      <para><emphasis>rds</emphasis> was developed to support the format
      definition of a new vendor-independent physical storage format for
      navigation databases within the PSI Consortium.</para>

      <para>The present document sketches a road map for extending
      <emphasis>rds</emphasis> to support embedded systems environments and to
      ensure forward compatibility of datamodels.</para>
    </section>
  </section>

  <section>
    <title>Current Status</title>

    <para>rds is developed as an open source project owned and managed by
    Harman/Becker, with contributions from other PSI partners. It is hosted at
    <ulink url="http://dstools.sourceforge.net">SourceForge</ulink>. rds is a
    Java command-line application. The core of rds is a DataScript parser
    (front-end) that builds an Abstract Syntax tree from one or more
    DataScript source files. rds has a number of optional extensions
    (back-ends) that generate various sorts of output from a parsed DataScript
    file.</para>

    <para>rds comes with the following extensions:</para>

    <itemizedlist>
      <listitem>
        <para><literal><literal>datascript.emit.java</literal>:</literal>
        Generates Java source code for reading and writing DataScript
        instances.</para>
      </listitem>

      <listitem>
        <para><literal>datascript.emit.html:</literal> Generates HTML
        documentation from DataScript sources, similar to Javadoc.</para>
      </listitem>

      <listitem>
        <para><literal>datascript.emit.xml:</literal> Generates an XML
        document representing the type hierarchy of a given DataScript
        model.</para>
      </listitem>
    </itemizedlist>

    <para>ADIT, one of the PSI partners, has developed a C++ backend called
    <literal>rds-cpp</literal> more or less equivalent to the Java backend.
    rds-cpp is not open source, and hence not part of the rds distribution.
    rds-cpp can be distributed to all PSI partners.</para>

    <para>The current code generators produce one target language class per
    DataScript type, which is too much overhead for resource-constrained
    environments. The presentation <ulink
    url="http://dstools.sourceforge.net/DataScriptInstanceParsing.pdf">DataScript
    Instance Parsing and Data Model Extensions</ulink> outlines the design of
    an event-based DataScript instance parser that minimizes the amount of
    generated code, improves the overall decoder performance and provides
    support for forward compatibility of applications relying on DataScript.
    </para>

    <para>The following section elaborates on this presentation and defines
    more detailed work packages for implementing this concept.</para>

    <para>As a prerequisite for implementing DataScript extensions, one should
    read the existing DataScript documentation, all available from the
    SourceForge site:</para>

    <itemizedlist>
      <listitem>
        <para>DataScript Language Overview</para>
      </listitem>

      <listitem>
        <para>Installing and Building Relational DataScript</para>
      </listitem>

      <listitem>
        <para>DataScript Developer Guidelines (not yet published)</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Road Map</title>

    <section>
      <title>Metamodel Definition</title>

      <para>Define a DataScript metamodel, i.e. a model describing the
      structure of a DataScript model. This model shall be specified in the
      DataScript language, hence the term metamodel. </para>

      <para>The result of this work package is a DataScript file
      <literal>metamodel.ds</literal>. The metamodel describes the format of a
      serialized binary representation of the Abstract Syntax Tree constructed
      by the DataScript parser from any user-defined DataScript model. The
      structure of the metamodel should as closely as possible reflect the
      structure of the AST.</para>

      <para>An <ulink
      url="https://dstools.svn.sourceforge.net/svnroot/dstools/trunk/rds/test/scripts/datascript/metamodel.ds">initial
      sketch</ulink> of this metamodel is in the Subversion repository at
      SourceForge.</para>
    </section>

    <section>
      <title>Binary Model Generation</title>

      <para>Develop an rds extension <literal>datascript.binmodel</literal>
      that outputs the binary metamodel for a given input. This extension
      should use the tree-based classes generated by rds from
      <literal>metamodel.ds</literal>. A new emitter populates the DataScript
      objects generated from the metamodel and then simply invokes the
      <literal>write()</literal> method of the top-level object to output the
      binary metamodel to a file.</para>
    </section>

    <section>
      <title>Semantic IDs for Java</title>

      <para>Develop an rds extension <literal>datascript.id.java</literal>
      that outputs Java constant definitions for all types and fields from a
      given DataScript model. The constants shall be <literal>public static
      final</literal> integers in a Java package that matches the
      corresponding DataScript package.</para>
    </section>

    <section>
      <title>Java Instance Parser </title>

      <para>Refine the first draft of the <ulink
      url="https://dstools.svn.sourceforge.net/svnroot/dstools/trunk/rds/test/src/datascript/instance/DataScriptInstanceParser.java"><literal>DataScriptInstanceParser</literal></ulink>
      interface and implement an instance parser providing this interface. The
      instance parser first loads a binary DataScript model. Having loaded the
      model, the parser can parse an instance of a model from a stream. If a
      <literal><ulink
      url="https://dstools.svn.sourceforge.net/svnroot/dstools/trunk/rds/test/src/datascript/instance/DataScriptInstanceHandler.java">DataScriptInstanceHandler</ulink></literal>
      has been passed to the parser, the parser will fire SAX-style events
      allowing the instance handler to interpret the content of the binary
      stream.</para>

      <para><literal>AstDataScriptInstanceParser</literal> (stored in the same
      folder) is a rudimentary proof-of-concept implementation of an instance
      parser that directly works on the AST constructed by rds from a
      DataScript source file, not on a binary model.</para>
    </section>

    <section>
      <title>Semantic IDs for Java</title>

      <para>Develop an rds extension <literal>datascript.id.cpp</literal> that
      outputs C++ constant definitions for all types and fields from a given
      DataScript model, similar to the
      <literal>datascript.id.java</literal>.extension.</para>
    </section>

    <section>
      <title>C++ Instance Parser</title>

      <para>Implement a C++ version of the Java instance parser that is
      suitable for an embedded environment and conforms to all coding style
      and design rules of Harman/Becker. The parser shall be reusable as a
      library in different contexts.</para>
    </section>

    <section>
      <title>Forward Compatibility</title>

      <para>Detailed work packages for this feature shall be defined at a
      later stage.</para>
    </section>
  </section>
</article>